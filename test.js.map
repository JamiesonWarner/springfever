{"version":3,"sources":["webpack:///webpack/bootstrap 3d60a7933850aaa4041e?5ab0","webpack:///./test/tests.ts","webpack:///./app/automata.ts?65e3","webpack:///./app/cell.ts?3336","webpack:///./app/utils.ts?926a","webpack:///./app/fluids.ts?322b","webpack:///./app/action.ts?41b2","webpack:///./app/angle.ts?1096","webpack:///./app/dna.ts?a36b","webpack:///./app/perceptron.ts?2f76","webpack:///./app/celltypes.ts?f607"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,EAAC;AACD;AACA;AACA;AACA;AACA,mDAAkD;AAClD,mDAAkD;AAClD,sDAAqD;AACrD,sDAAqD;AACrD,sDAAqD;AACrD,sDAAqD;AACrD,sDAAqD;AACrD,sDAAqD;AACrD,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,EAAC;;;;;;;;AC9DD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD;AACA,8BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD,8BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD,8BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD,8BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA,gCAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA,wBAAuB,oBAAoB;AAC3C;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA,wBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA,wBAAuB,uBAAuB;AAC9C;AACA;AACA,4BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAA+D,8BAA8B;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD;AACA,8BAA6B,+BAA+B;AAC5D;AACA,gCAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC,wBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD,8BAA6B,+BAA+B;AAC5D,gCAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,8BAA8B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD,8BAA6B,+BAA+B;AAC5D;AACA;AACA,gCAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD,8BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C;AAC7C,8CAA6C;AAC7C,iDAAgD;AAChD;AACA,EAAC;AACD;;;;;;;ACrbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,uBAAuB;AACjD;AACA;AACA;AACA,2BAA0B,uBAAuB;AACjD,+BAA8B,sBAAsB,OAAO;AAC3D;AACA;AACA,2BAA0B,+BAA+B;AACzD;AACA;AACA;AACA;AACA;AACA,2BAA0B,gBAAgB;AAC1C;AACA;AACA,2BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,oBAAoB;AAC3C,4FAA2F;AAC3F;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA,2BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AC/DA;AACA;AACA;AACA;AACA,yBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA,wBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA,wBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACrDA;AACA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,YAAY;AAC5C,wBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,YAAY;AAC5C;AACA,wBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,YAAY;AAC5C;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,YAAY;AAC5C;AACA;AACA,EAAC;AACD;;;;;;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,8BAA8B;;;;;;;AClG/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,oDAAoD;AACrF,wCAAuC,wDAAwD;AAC/F,wCAAuC,yDAAyD;AAChG,sCAAqC,mEAAmE;AACxG,sCAAqC,mEAAmE;AACxG,iCAAgC,iCAAiC;AACjE,uCAAsC,iCAAiC;AACvE,uCAAsC,iCAAiC;AACvE,uCAAsC,iCAAiC;AACvE,uCAAsC,iCAAiC;AACvE,uCAAsC,kCAAkC;AACxE,uCAAsC,kCAAkC;AACxE,uCAAsC,kCAAkC;AACxE,4CAA2C,YAAY;AACvD,4CAA2C,YAAY;AACvD,4CAA2C,YAAY;AACvD,4CAA2C,YAAY;AACvD,4CAA2C,YAAY;AACvD;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA,4BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,YAAY;AAC5C;AACA,wBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA,wBAAuB,2BAA2B;AAClD;AACA,4BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B;AAC9B,iCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,cAAc;AAC9C,qCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA,wBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACnIA;AACA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,cAAc;AAC9C;AACA;AACA;AACA,wBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,oBAAoB;AAC3C;AACA;AACA,2BAA0B,yBAAyB;AACnD,+BAA8B,4BAA4B;AAC1D,mCAAkC,+BAA+B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD","file":"test.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 3d60a7933850aaa4041e\n **/","\"use strict\";\nvar perceptron_1 = require(\"../app/perceptron\");\nvar dna_1 = require(\"../app/dna\");\ndescribe(\"dnaSerializer\", function () {\n    it(\"works\", function () {\n        var dna = new dna_1.DNA();\n        dna.mutate(1);\n        var val = dna.cellTypes[0].actionPerceptrons[0].activate([1, 2, 3, 4, 5, 6]);\n        var dna2 = dna.clone();\n        var val2 = dna2.cellTypes[0].actionPerceptrons[0].activate([1, 2, 3, 4, 5, 6]);\n        console.log(val, val2);\n        expect(val).toEqual(val2);\n        expect(dna).not.toEqual(dna2);\n    });\n});\ndescribe(\"perceptron\", function () {\n    it(\"initializes to expected values\", function () {\n        var p = new perceptron_1.Perceptron(4, 2, 4);\n        // expect(p.weights.length).toEqual(2);\n        // expect(p.weights[0].length).toEqual(2); // 2 nodes in hidden layer\n        // expect(p.weights[1].length).toEqual(4); // 4 nodes in output layer\n        // expect(p.weights[0][0].length).toEqual(5); // 4 inputs + constant\n        // expect(p.weights[0][1].length).toEqual(5); // 4 inputs + constant\n        // expect(p.weights[1][0].length).toEqual(3); // 2 inputs + constant\n        // expect(p.weights[1][1].length).toEqual(3); // 2 inputs + constant\n        // expect(p.weights[1][2].length).toEqual(3); // 2 inputs + constant\n        // expect(p.weights[1][3].length).toEqual(3); // 2 inputs + constant\n    });\n    it(\"gets reasonable net values\", function () {\n        var p = new perceptron_1.Perceptron(2, 2, 1);\n        p.trainer.XOR();\n        expect(p.activate([0, 0]) < 0.2).toEqual(true);\n        expect(p.activate([0, 1]) > 0.8);\n        expect(p.activate([1, 0]) > 0.8);\n        expect(p.activate([1, 1]) < 0.2);\n        // p.weights[0][0][0] = 1.0;\n        // p.weights[0][0][1] = 0.6;\n        // p.weights[0][0][2] = 0.6;\n        // p.weights[0][1][0] = 1.0;\n        // p.weights[0][1][1] = 1.1;\n        // p.weights[0][1][2] = 1.1;\n        // p.weights[1][0][0] = 1.0;\n        // p.weights[1][0][1] = -2;\n        // p.weights[1][0][2] = 1.1;\n        console.log('vallls');\n        // console.log(p.activate([0,0]));\n        // console.log(p.activate([0,1]));\n        // console.log(p.activate([1,0]));\n        // console.log(p.activate([1,1]));\n        expect(true).toEqual(true);\n        // xor function\n        // var p = new Perceptron(1, 1);\n        // expect(p.weights.length).toEqual(2);\n        // expect(p.weights[0].length).toEqual(2);\n        // expect(p.weights[1].length).toEqual(4);\n    });\n    it(\"perturbs correctly\", function () {\n        var p = new perceptron_1.Perceptron(2, 2, 1);\n        // expect(p.net([0, 0])).toEqual(0);\n        // p.perturb(1);\n        // expect(p.net([0, 0])).not.toEqual(0);\n    });\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/tests.ts\n ** module id = 0\n ** module chunks = 1\n **/","\"use strict\";\nvar cell_1 = require(\"./cell\");\nvar fluids_1 = require(\"./fluids\");\nvar action_1 = require(\"./action\");\nvar angle_1 = require(\"./angle\");\n/*\nTODO turn Automata into systems model.\nAutomata is a place for shared state.\nAutomata just stores stuff like the fluidsArray, and its state is transformed by Systems.\n*/\nvar Automata = (function () {\n    function Automata(runString, drawCanvas) {\n        this.canvas = drawCanvas;\n        this.canvas.setAttribute('width', Automata.GRID_N_COLUMNS * Automata.CELL_SCALE_PIXELS);\n        this.canvas.setAttribute('height', Automata.GRID_N_ROWS * Automata.CELL_SCALE_PIXELS);\n        this.canvasCtx = this.canvas.getContext(\"2d\");\n        this.fluidsArray = new Array(Automata.GRID_N_ROWS);\n        for (var row = 0; row < Automata.GRID_N_ROWS; row++) {\n            this.fluidsArray[row] = new Array(Automata.GRID_N_COLUMNS);\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; ++col) {\n                // create fluid for each location in the fluids array\n                var water;\n                if (this.isDirtCell(row, col))\n                    water = Math.random() * 2 * Automata.MATERIAL_DIRT_WATER_MEAN;\n                else\n                    water = Math.random() * 2 * Automata.MATERIAL_AIR_WATER_MEAN;\n                this.fluidsArray[row][col] = new fluids_1.Fluids(water, 0);\n            }\n        }\n        this.cellArray = new Array(Automata.GRID_N_ROWS);\n        for (var row = 0; row < Automata.GRID_N_ROWS; row++) {\n            this.cellArray[row] = new Array(Automata.GRID_N_COLUMNS);\n        }\n        var self = this;\n        drawCanvas.addEventListener(\"mousemove\", function (event) {\n            self.showInfo(event.offsetX, event.offsetY);\n        });\n    }\n    Automata.prototype.plantSeed = function (seed) {\n        // remove all existing plants and add the specified seed\n        for (var row = 0; row < Automata.GRID_N_ROWS; ++row) {\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; ++col) {\n                this.cellArray[row][col] = undefined;\n            }\n        }\n        this.plant = seed.plantSeed(this.cellArray, this.fluidsArray);\n        this.dna = seed;\n    };\n    Automata.prototype.isAirCell = function (row, col) {\n        return row < 50;\n    };\n    Automata.prototype.isDirtCell = function (row, col) {\n        return row >= 50;\n    };\n    Automata.prototype.printGridFluids = function () {\n        for (var row = 0; row < Automata.GRID_N_ROWS; ++row) {\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; ++col) {\n                console.log(this.fluidsArray[row][col].vector);\n            }\n        }\n    };\n    Automata.prototype.validateFluidsArray = function () {\n        for (var row = 0; row < Automata.GRID_N_ROWS; ++row) {\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; ++col) {\n                var f = this.fluidsArray[row][col].vector;\n                if (typeof f === 'undefined')\n                    console.log('row,col are: ', row, col);\n                for (var k = 0; k < f.length; ++k) {\n                    if (typeof f[k] !== 'number' || isNaN(f[k])) {\n                        throw new Error('Error: Invalid fluid vector at: ' + row + ', ' + col);\n                    }\n                    if (f[k] < 0) {\n                        console.log('Warning: Negative fluids at: ', row, col);\n                        return;\n                    }\n                }\n            }\n        }\n    };\n    Automata.prototype.showInfo = function (x, y) {\n        var tx = x / Automata.CELL_SCALE_PIXELS;\n        var ty = y / Automata.CELL_SCALE_PIXELS;\n        var row = Math.floor(ty);\n        var col = Math.floor(tx);\n        var fluids = this.fluidsArray[row][col];\n        document.getElementById('bar-water').style.width = fluids.vector[fluids_1.Fluids.WATER] + 'px';\n        document.getElementById('bar-glucose').style.width = fluids.vector[fluids_1.Fluids.GLUCOSE] + 'px';\n        document.getElementById('bar-auxin').style.width = (40 * fluids.vector[fluids_1.Fluids.AUXIN]) + 'px';\n        document.getElementById('text-water').innerHTML = \"\" + fluids.vector[fluids_1.Fluids.WATER];\n        document.getElementById('text-glucose').innerHTML = \"\" + fluids.vector[fluids_1.Fluids.GLUCOSE];\n        document.getElementById('text-auxin').innerHTML = \"\" + fluids.vector[fluids_1.Fluids.AUXIN];\n    };\n    Automata.prototype.update = function () {\n        //console.log(\"tick\");\n        // if (this.plant.length)\n        //     console.log('cell fluids', this.plant[0].fluids.vector);\n        this.doCellActions();\n        this.doPassiveFlowAndPhotosynthesis();\n        this.doCellMetabolism();\n        this.cellDeath();\n        // this.signalsUpdate();\n    };\n    Automata.prototype.doCellActions = function () {\n        // Calc actions on this frame\n        var actions = new Array(this.plant.length);\n        var cell;\n        for (var i = 0; i < this.plant.length; i++) {\n            cell = this.plant[i];\n            actions[i] = cell.chooseAction();\n        }\n        // Apply actions on this frame\n        for (var i = 0; i < actions.length; i++) {\n            if (!actions[i]) {\n                continue; // cell chose to do nothing\n            }\n            var action = actions[i];\n            var cell = this.plant[i];\n            if (action instanceof action_1.DivideAction) {\n                // console.log(\"cell wants to grow...\")\n                var daction = action;\n                // calculate direction of this action\n                var neighborUp = this.fluidsArray[cell.row - 1][cell.col];\n                var neighborRight = this.fluidsArray[cell.row][cell.col + 1];\n                var neighborDown = this.fluidsArray[cell.row + 1][cell.col];\n                var neighborLeft = this.fluidsArray[cell.row][cell.col - 1];\n                var angle = daction.getActionDirection(neighborUp, neighborRight, neighborDown, neighborLeft);\n                var direction = angle_1.Angle.sampleDirection(angle);\n                var drow = angle_1.Angle.directionDeltaRow(direction);\n                var dcol = angle_1.Angle.directionDeltaCol(direction);\n                var gI = this.plant[i].row + drow;\n                var gJ = this.plant[i].col + dcol;\n                var cost = cell.type.cost;\n                var canAfford = true;\n                for (var j = 0; j < cost.vector.length; j++) {\n                    if (this.plant[i].fluids.vector[j] < cost.vector[j]) {\n                        canAfford = false;\n                        break;\n                    }\n                }\n                if (!canAfford) {\n                    // console.log(\"cell can't afford...\")\n                    continue;\n                }\n                if (gI < 0 || gI >= Automata.GRID_N_ROWS || gJ < 0 || gJ >= Automata.GRID_N_COLUMNS) {\n                    // console.log(\"cannot make cell at \" + gJ + \", \" + gI);\n                    continue;\n                }\n                if (this.cellArray[gI][gJ]) {\n                    // console.log(\"cell already exists at \" + gJ + \", \" + gI);\n                    continue;\n                }\n                this.subtractFluids(cell.fluids, cost);\n                var newFluids = this.splitFluids(cell.fluids);\n                var nCell = new cell_1.Cell(this.dna, cell.type, newFluids, gI, gJ);\n                this.plant.push(nCell);\n                this.fluidsArray[gI][gJ] = newFluids;\n                this.cellArray[gI][gJ] = nCell;\n            }\n            else if (action instanceof action_1.SpecializeAction) {\n                var saction = action;\n                cell.setType(saction.toType);\n            }\n        }\n    };\n    /*\n    Kill all cells who don't have enough resources to live\n    */\n    Automata.prototype.cellDeath = function () {\n        var MIN_WATER = 0.1 * Automata.MATERIAL_WATER_WATER_MEAN;\n        var MIN_GLUCOSE = 0.001;\n        var toKill = [];\n        for (var i = 0; i < this.plant.length; ++i) {\n            var cell = this.plant[i];\n            if (!cell.fluids)\n                continue;\n            if (cell.fluids.vector[fluids_1.Fluids.GLUCOSE] < MIN_GLUCOSE ||\n                cell.fluids.vector[fluids_1.Fluids.WATER] < MIN_WATER) {\n                // kill cell\n                toKill.push(cell);\n            }\n            if (cell.fluids.vector[fluids_1.Fluids.GLUCOSE] < MIN_GLUCOSE) {\n            }\n            if (cell.fluids.vector[fluids_1.Fluids.WATER] < MIN_WATER) {\n            }\n        }\n        for (var i = 0; i < toKill.length; ++i) {\n            var cell = toKill[i];\n            // console.log('Killing cell at: ', cell.row, cell.col);\n            var index = this.plant.indexOf(cell);\n            this.plant.splice(index, 1);\n            // this.fluidsArray[cell.row][cell.col] = cell.fluids;\n            this.cellArray[cell.row][cell.col] = undefined;\n        }\n    };\n    Automata.prototype.subtractFluids = function (a, b) {\n        for (var i = 0; i < a.vector.length; i++) {\n            a.vector[i] -= b.vector[i];\n        }\n    };\n    Automata.prototype.splitFluids = function (fluids) {\n        var newFluids = new fluids_1.Fluids();\n        for (var i = 0; i < fluids.vector.length; i++) {\n            fluids.vector[i] /= 2;\n            newFluids.vector[i] = fluids.vector[i];\n        }\n        return newFluids;\n    };\n    Automata.prototype.signalsUpdate = function () {\n        // Update each cell's individual signal levels\n        for (var i = 0; i < this.plant.length; ++i) {\n            var cell = this.plant[i];\n            cell.updateSignals();\n        }\n        // Send signals to neighbors\n        var SPREAD_COEFF = 0.1;\n        for (var i = 0; i < this.plant.length; i++) {\n            var cell = this.plant[i];\n            var neighbs = [[-1, 0], [1, 0], [0, 1], [0, -1]];\n            for (var j = 0; j < neighbs.length; j++) {\n                var nrow = cell.col + neighbs[j][0];\n                var ncol = cell.row + neighbs[j][1];\n                if (ncol < 0 || nrow < 0 || ncol >= Automata.GRID_N_COLUMNS || nrow >= Automata.GRID_N_ROWS)\n                    continue;\n                var neighbFluids = this.fluidsArray[nrow][ncol];\n                if (neighbFluids instanceof cell_1.Cell) {\n                    var nsignals = neighbFluids.vector;\n                    for (var k = fluids_1.Fluids.SIGNALS_START; k < fluids_1.Fluids.N_FLUIDS; k++) {\n                        if (cell.fluids[k] < nsignals[k])\n                            continue;\n                        var amount = SPREAD_COEFF * cell.fluids.vector[k];\n                        nsignals[k] += amount;\n                        cell.fluids.vector[k] -= amount;\n                    }\n                }\n            }\n        }\n    };\n    Automata.prototype.doCellMetabolism = function () {\n        // respiration. this is needed for metabolism\n        var RESPIRATION_AMOUNT = 0.01;\n        for (var i = 0; i < this.plant.length; ++i) {\n            var cell = this.plant[i];\n            cell.fluids.vector[fluids_1.Fluids.WATER] -= RESPIRATION_AMOUNT;\n            cell.fluids.vector[fluids_1.Fluids.GLUCOSE] -= RESPIRATION_AMOUNT;\n        }\n    };\n    Automata.prototype.doPassiveFlowAndPhotosynthesis = function () {\n        // Initialize fluidsDiff to 0's\n        var fluidsDiff = new Array(Automata.GRID_N_ROWS);\n        for (var row = 0; row < Automata.GRID_N_ROWS; row++) {\n            fluidsDiff[row] = new Array(Automata.GRID_N_COLUMNS);\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; ++col) {\n                fluidsDiff[row][col] = new Array(fluids_1.Fluids.N_FLUIDS);\n                for (var i = 0; i < fluids_1.Fluids.N_FLUIDS; ++i) {\n                    fluidsDiff[row][col][i] = 0;\n                }\n            }\n        }\n        // photosynthesis. TODO this will be an action\n        var REACTION_FACTOR = 10; // expend 1 water to get 4 glucose\n        for (var i = 0; i < this.plant.length; i++) {\n            var cell = this.plant[i];\n            if (cell.type.isLeaf) {\n                var numAir = this.countAirNeighbors(cell.row, cell.col);\n                var dGlucose = Math.min(cell.fluids.vector[fluids_1.Fluids.WATER] / 4, 100 * numAir);\n                // convert water to glucose\n                fluidsDiff[cell.row][cell.col][fluids_1.Fluids.WATER] -= dGlucose;\n                fluidsDiff[cell.row][cell.col][fluids_1.Fluids.GLUCOSE] += REACTION_FACTOR * dGlucose;\n            }\n        }\n        // Passive transport / diffusion. Give nutrients to neighbors.\n        // console.log(fluidsDiff);\n        var neighbs = [[-1, 0], [1, 0], [0, 1], [0, -1]];\n        for (var row = 0; row < Automata.GRID_N_ROWS; ++row) {\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; ++col) {\n                for (var i = 0; i < neighbs.length; ++i) {\n                    var neighbRow = row + neighbs[i][0];\n                    var neighbCol = col + neighbs[i][1];\n                    if (!this.isPositionOnGrid(neighbRow, neighbCol)) {\n                        continue;\n                    }\n                    var flowRate = 0.1;\n                    // air to air is very fast\n                    if (this.isAirNotCell(row, col) && this.isAirNotCell(neighbRow, neighbCol)) {\n                        flowRate = 0.2;\n                    }\n                    if (this.cellArray[row][col] && !this.cellArray[neighbRow][neighbCol] ||\n                        !this.cellArray[row][col] && this.cellArray[neighbRow][neighbCol]) {\n                        // flowRate = 0.01\n                        continue;\n                    }\n                    var neighbFluids = this.fluidsArray[neighbRow][neighbCol].vector;\n                    var fluids = this.fluidsArray[row][col].vector;\n                    for (var j = 0; j < fluids_1.Fluids.N_FLUIDS; ++j) {\n                        if (fluids[j] > neighbFluids[j]) {\n                            var diff = flowRate * (fluids[j] - neighbFluids[j]);\n                            fluidsDiff[row][col][j] -= diff;\n                            fluidsDiff[neighbRow][neighbCol][j] += diff;\n                        }\n                    }\n                }\n            }\n        }\n        // this.validateFluidsArray();\n        // Apply fluidsDiff to fluids\n        for (var row = 0; row < Automata.GRID_N_ROWS; row++) {\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; col++) {\n                var fluids = this.fluidsArray[row][col].vector;\n                var fluidDiff = fluidsDiff[row][col];\n                for (var i = 0; i < fluids_1.Fluids.N_FLUIDS; ++i) {\n                    fluids[i] += fluidDiff[i];\n                }\n            }\n        }\n    };\n    Automata.prototype.isPositionOnGrid = function (row, col) {\n        return row >= 0 && col >= 0 &&\n            row < Automata.GRID_N_ROWS && col < Automata.GRID_N_COLUMNS;\n    };\n    Automata.prototype.isAirNotCell = function (row, col) {\n        // cell is dead and cell is air cell\n        if (!this.isPositionOnGrid(row, col))\n            return false;\n        return row < 50 && !this.cellArray[row][col];\n    };\n    Automata.prototype.countAirNeighbors = function (row, col) {\n        var n = (this.isAirNotCell(row - 1, col) ? 1 : 0) +\n            (this.isAirNotCell(row + 1, col) ? 1 : 0) +\n            (this.isAirNotCell(row, col - 1) ? 1 : 0) +\n            (this.isAirNotCell(row, col + 1) ? 1 : 0);\n        return n;\n    };\n    Automata.prototype.draw = function () {\n        if (this.validateFluidsArray()) {\n            console.log('error in fluids, skipping draw');\n            return;\n        }\n        var scale = Automata.CELL_SCALE_PIXELS;\n        this.canvasCtx.lineWidth = 3;\n        this.canvasCtx.fillStyle = \"#7EC0DD\";\n        this.canvasCtx.fillRect(0, 0, Automata.GRID_N_COLUMNS * scale, scale * Automata.GRID_N_ROWS);\n        this.canvasCtx.fillRect(0, 0, 100, 100);\n        for (var row = 0; row < Automata.GRID_N_ROWS; row++) {\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; col++) {\n                var fluids = this.fluidsArray[row][col].vector;\n                var waterContent = Math.max(Math.min(Math.round(fluids[fluids_1.Fluids.WATER]), 255), 0);\n                if (this.drawStyle === 'water') {\n                    var waterConcentration = fluids[fluids_1.Fluids.WATER] / (2 * Automata.MATERIAL_DIRT_WATER_MEAN);\n                    var waterColor = Math.max(Math.min(Math.round(255 * waterConcentration), 255), 0);\n                    var colorString = \"#\" + \"0064\" + this.getColorHex(waterColor);\n                    this.canvasCtx.fillStyle = colorString;\n                }\n                else if (this.drawStyle === 'glucose') {\n                    if (this.cellArray[row][col]) {\n                        this.canvasCtx.fillStyle = \"#\" + this.getColorHex(Math.min(255, Math.ceil(fluids[fluids_1.Fluids.GLUCOSE]))) + \"0000\";\n                    }\n                    else {\n                        this.canvasCtx.fillStyle = \"#000000\";\n                    }\n                }\n                else if (this.drawStyle === 'auxin') {\n                    var cell = this.cellArray[row][col];\n                    if (cell) {\n                        this.canvasCtx.fillStyle = \"#\" + \"0000\" + this.getColorHex(Math.min(255, Math.ceil(255 * fluids[fluids_1.Fluids.SIGNALS_START])));\n                    }\n                    else {\n                        this.canvasCtx.fillStyle = \"#000000\";\n                    }\n                }\n                else {\n                    var cell = this.cellArray[row][col];\n                    if (cell) {\n                        this.canvasCtx.fillStyle = cell.type.color;\n                    }\n                    else if (row >= 50) {\n                        var cval = Math.ceil(waterContent / 4);\n                        // console.log(waterContent);\n                        this.canvasCtx.fillStyle = \"#3311\" + this.getColorHex(cval);\n                    }\n                    else {\n                        this.canvasCtx.fillStyle = \"#7EC0DD\";\n                    }\n                }\n                this.canvasCtx.fillRect(Math.floor(scale * col), Math.floor(scale * row), scale, scale);\n                // draw green outline around the plant\n                if (this.drawStyle == 'water' || this.drawStyle == 'glucose' || this.drawStyle == 'auxin') {\n                    this.canvasCtx.strokeStyle = \"#009900\";\n                    var neighbs = [[-1, 0], [1, 0], [0, 1], [0, -1]];\n                    var cell = this.cellArray[row][col];\n                    if (cell) {\n                        for (var i = 0; i < neighbs.length; ++i) {\n                            var nrow = row + neighbs[i][0];\n                            var ncol = col + neighbs[i][1];\n                            if (this.isPositionOnGrid(nrow, ncol) && !this.cellArray[nrow][ncol]) {\n                                this.canvasCtx.beginPath();\n                                if (neighbs[i][0] == -1) {\n                                    this.canvasCtx.moveTo(scale * col + 0.5, scale * row + 0.5);\n                                    this.canvasCtx.lineTo(scale * (col + 1) + 0.5, scale * row + 0.5);\n                                }\n                                else if (neighbs[i][0] == 1) {\n                                    this.canvasCtx.moveTo(scale * (col + 1) + 0.5, scale * (row + 1) + 0.5);\n                                    this.canvasCtx.lineTo(scale * col + 0.5, scale * (row + 1) + 0.5);\n                                }\n                                else if (neighbs[i][1] == -1) {\n                                    this.canvasCtx.moveTo(scale * col + 0.5, scale * (row + 1) + 0.5);\n                                    this.canvasCtx.lineTo(scale * col + 0.5, scale * row + 0.5);\n                                }\n                                else if (neighbs[i][1] == 1) {\n                                    this.canvasCtx.moveTo(scale * (col + 1) + 0.5, scale * row + 0.5);\n                                    this.canvasCtx.lineTo(scale * (col + 1) + 0.5, scale * (row + 1) + 0.5);\n                                }\n                                this.canvasCtx.stroke();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    Automata.prototype.getColorHex = function (byte) {\n        var colorString = \"\";\n        if (byte < 16) {\n            colorString += \"0\" + byte.toString(16);\n        }\n        else {\n            colorString += byte.toString(16);\n        }\n        return colorString;\n    };\n    Automata.GRID_N_COLUMNS = 120;\n    Automata.GRID_N_ROWS = 100;\n    Automata.CELL_SCALE_PIXELS = 8;\n    Automata.MATERIAL_WATER_WATER_MEAN = 1.0; // used to estimate turgidity. Wolfram Alpha: mass of 1cm^3 water\n    Automata.MATERIAL_DIRT_WATER_MEAN = 0.21; // Wolfram Alpha: mass of 1 cm^3 moist soil - Wolfram Alpha: mass of 1cm^3 dry soil;\n    Automata.MATERIAL_AIR_WATER_MEAN = 1.519e-5; // Wolfram Alpha: mass of water vapor in 1 cubic centimer air;\n    return Automata;\n}());\nexports.Automata = Automata;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/automata.ts\n ** module id = 2\n ** module chunks = 0 1\n **/","\"use strict\";\nvar utils_1 = require(\"./utils\");\n/*\nCell is a fleighweight object for the Grid. Systems.\nPlus they also have context for fitting into the Grid.\nIt can also be thought of as a DNA controller.\n*/\nvar Cell = (function () {\n    function Cell(dna, type, fluids, row, col) {\n        this.row = row;\n        this.col = col;\n        this.fluids = fluids;\n        this.dna = dna;\n        this.setType(type);\n    }\n    /*\n    Pass either a literal type object or a numerical type index referencing dna type definitions\n    */\n    Cell.prototype.setType = function (type) {\n        if (typeof type === 'number') {\n            this.type = this.dna.cellTypes[type];\n        }\n        else {\n            this.type = type;\n        }\n    };\n    Cell.prototype.updateSignals = function () {\n        // multiply by matrix\n        // var newSignals = new Array(Fluids.N_SIGNALS);\n        // for (var i = 0; i < newSignals.length; ++i) {\n        //     newSignals[i] = 0;\n        // }\n        // var mtx = this.type.signalMatrix;\n        // for (var i = 0; i < newSignals.length; i++) {\n        //     for (var j = 0; j < Fluids.N_SIGNALS; j++) { // first SIGNALS columns of matrix...\n        //         newSignals[i] += this.fluids.vector[j+Fluids.SIGNALS_START] * mtx[i][j];\n        //     }\n        //     for (j = 0; j < this.fluids.vector.length; ++j) {\n        //         newSignals[i] += this.fluids.vector[j] * mtx[i][j+this.signals.vector.length];\n        //     }\n        // }\n        // var vec = this.dna.cellTypes[this.type].signalB;\n        // // console.log('signals', newSignals, 'mtx', mtx, 'vec', vec);\n        // for (var i = 0; i < vec.length; i++) {\n        //     newSignals[i] += vec[i];\n        // }\n        // for (var i = 0; i < newSignals.length; i++) {\n        //     this.signals.vector[i] = Math.max(0, Math.min(1, newSignals[i]));\n        // }\n    };\n    Cell.prototype.getActionPotential = function (action) {\n        return 0;\n    };\n    Cell.prototype.chooseAction = function () {\n        // var signals = this.signals,\n        //     cellType = this.type;\n        // var perceptron = this.type.\n        // Calculate which actions have high potential values\n        var actions = this.dna.actions;\n        var potentials = new Array(actions.length);\n        for (var i = 0; i < actions.length; ++i) {\n            potentials[i] = this.type.actionPerceptrons[i].activate(this.fluids.vector)[0]; // this.getActionPotential(actions[i]);\n        }\n        var bestIndex = utils_1.Utils.argmax(potentials);\n        // console.log('choosing action, ', actions[bestIndex]);\n        if (potentials[bestIndex] < 0.5) {\n            return null; // \"empty\" action\n        }\n        return actions[bestIndex];\n        // for (var i = 0; i < activators.length; ++i) {\n        //     activators[i] = this.activatorFunction(this.distanceToActivator(signals, actions[i].activator));\n        // }\n        // // console.log('activators', activators, 'actions', actions);\n        // return this.weightedChoose(actions, activators);\n    };\n    return Cell;\n}());\nexports.Cell = Cell;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/cell.ts\n ** module id = 3\n ** module chunks = 0 1\n **/","\"use strict\";\nvar Utils = (function () {\n    function Utils() {\n    }\n    /*\n    Returns a random number between -bound and bound\n    */\n    Utils.getBoundedRandom = function (bound) {\n        return 2 * bound * Math.random() - bound;\n    };\n    Utils.crossProduct = function (arr1, arr2) {\n        var sum = 0;\n        var length = Math.min(arr1.length, arr2.length);\n        for (var i = 0; i < length; ++i) {\n            sum += arr1[i] * arr2[i];\n        }\n        return sum;\n    };\n    Utils.l2norm = function (arr) {\n        var n = 0;\n        for (var i = 0; i < arr.length; ++i) {\n            n += arr[i] * arr[i];\n        }\n        return Math.sqrt(n);\n    };\n    Utils.l1norm = function (arr) {\n        var n = 0;\n        for (var i = 0; i < arr.length; ++i) {\n            n += arr[i];\n        }\n        return n;\n    };\n    Utils.distanceToPlane = function (fluids, activator) {\n        var normW = Utils.l2norm(activator.w);\n        var d = 0;\n        for (var i = 0; i < length; ++i) {\n            d += fluids[i] * activator[i];\n        }\n        d += activator.b;\n        return d / normW;\n    };\n    /*\n    Sigmoid activator.\n    Returns value from 0 to 1 given f from -inf to inf.\n    */\n    Utils.activatorFunction = function (v) {\n        return 1 / (1 + Math.exp(-v));\n    };\n    Utils.argmax = function (arr) {\n        if (!arr.length)\n            return undefined;\n        var max = arr[0];\n        var argmax = 0;\n        for (var i = 1; i < arr.length; ++i) {\n            if (arr[i] > max) {\n                argmax = i;\n                max = arr[i];\n            }\n        }\n        return argmax;\n    };\n    return Utils;\n}());\nexports.Utils = Utils;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/utils.ts\n ** module id = 4\n ** module chunks = 0 1\n **/","\"use strict\";\nvar Fluids = (function () {\n    function Fluids() {\n        var vec = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            vec[_i - 0] = arguments[_i];\n        }\n        this.vector = new Array(Fluids.N_FLUIDS);\n        for (var i = 0; i < Fluids.N_FLUIDS; ++i) {\n            this.vector[i] = vec[i] || 0;\n        }\n    }\n    Fluids.prototype.sumFluids = function () {\n        var s = 0;\n        for (var i = 0; i < this.vector.length; ++i) {\n            s += this.vector[i];\n        }\n        return s;\n    };\n    Fluids.prototype.getPressureInArea = function (area) {\n        return this.sumFluids() / area;\n    };\n    /*\n    Goal:  q\n    */\n    /*\n    Returns the quantity of a given fluid, which is the amount of a substance per unit volume.\n    divided by the total fluid.\n\n    */\n    /*\n\n    */\n    Fluids.prototype.getFluidConcentration = function (fluidId, area) {\n    };\n    /*\n    Diffusive flux is rate of flow per unit area. Positive value means outward flow.\n\n    Fick's law of diffusion: J = -D (d phi)/(d x)\n    J is diffusive flux\n    D is diffusion coefficient\n    phi is amount of\n    x is position\n    */\n    Fluids.prototype.getDiffusiveFlux = function (toFluid, area1, area2) { };\n    Fluids.WATER = 0;\n    Fluids.GLUCOSE = 1;\n    Fluids.AUXIN = 2;\n    Fluids.SIGNALS_START = 2;\n    Fluids.N_SIGNALS = 4;\n    Fluids.N_FLUIDS = 2 + Fluids.N_SIGNALS;\n    return Fluids;\n}());\nexports.Fluids = Fluids;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/fluids.ts\n ** module id = 5\n ** module chunks = 0 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar utils_1 = require(\"./utils\");\nvar ActionSerializer = (function () {\n    function ActionSerializer() {\n    }\n    ActionSerializer.serialize = function (action) {\n        var cls;\n        if (action.constructor == DivideAction) {\n            cls = \"DivideAction\";\n        }\n        else if (action.constructor == PumpAction) {\n            cls = \"PumpAction\";\n        }\n        else if (action.constructor == ReactAction) {\n            cls = \"ReactAction\";\n        }\n        else if (action.constructor == SpecializeAction) {\n            cls = \"SpecializeAction\";\n        }\n        else {\n            throw new TypeError(\"Did not recognize the specified action type\");\n        }\n        var obj = {\n            class: cls\n        };\n        if (action instanceof DirectionalAction) {\n            obj['fluidGradient'] = action.fluidGradient;\n            obj['gravityGradient'] = action.gravityGradient;\n            obj['sunGradient'] = action.sunGradient;\n        }\n        else if (action instanceof ReactAction) {\n            obj['reaction'] = action.reaction;\n        }\n        else if (action instanceof SpecializeAction) {\n            obj['toType'] = action.toType;\n        }\n        else if (action instanceof PumpAction) {\n            obj['fluids'] = action.fluids;\n        }\n        return JSON.stringify(obj);\n    };\n    ActionSerializer.deserialize = function (jsonAction) {\n        var obj = jsonAction;\n        try {\n            if (typeof obj === 'string') {\n                obj = JSON.parse(jsonAction);\n            }\n        }\n        catch (e) {\n            console.log('Failure to parse action: ', jsonAction);\n            throw e;\n        }\n        switch (obj.class) {\n            case \"DivideAction\":\n                return new DivideAction(obj);\n            case \"PumpAction\":\n                return new PumpAction(obj);\n            case \"ReactAction\":\n                return new ReactAction(obj);\n            case \"SpecializeAction\":\n                return new SpecializeAction(obj);\n            default:\n                console.log(obj, typeof obj);\n                throw new TypeError(\"Bad jsonAction\");\n        }\n    };\n    return ActionSerializer;\n}());\nexports.ActionSerializer = ActionSerializer;\nvar DirectionalAction = (function () {\n    function DirectionalAction(args) {\n        this.fluidGradient = args['fluidGradient'];\n        this.gravityGradient = args['gravityGradient'];\n        this.sunGradient = args['sunGradient'];\n    }\n    DirectionalAction.prototype.getActionDirection = function (upFluids, rightFluids, downFluids, leftFluids) {\n        var upContribution = utils_1.Utils.crossProduct(upFluids, this.fluidGradient);\n        var rightContribution = utils_1.Utils.crossProduct(rightFluids, this.fluidGradient);\n        var downContribution = utils_1.Utils.crossProduct(downFluids, this.fluidGradient);\n        var leftContribution = utils_1.Utils.crossProduct(leftFluids, this.fluidGradient);\n        if (this.gravityGradient) {\n            downContribution += this.gravityGradient;\n        }\n        var direction = Math.atan2(upContribution - downContribution, rightContribution - leftContribution);\n        return direction;\n    };\n    /*\n    Calculate the angle that this action points to\n    */\n    DirectionalAction.prototype.getGradientToFluids = function () {\n    };\n    DirectionalAction.prototype.mutate = function (amount) {\n        if (amount === void 0) { amount = 1; }\n        for (var i = 0; i < this.fluidGradient.length; ++i) {\n            var r = utils_1.Utils.getBoundedRandom(amount);\n            this.fluidGradient[i] += r;\n        }\n        if (typeof this.gravityGradient != 'undefined')\n            this.gravityGradient += utils_1.Utils.getBoundedRandom(amount);\n        if (typeof this.sunGradient != 'undefined')\n            this.sunGradient += utils_1.Utils.getBoundedRandom(amount);\n    };\n    return DirectionalAction;\n}());\nexports.DirectionalAction = DirectionalAction;\nvar DivideAction = (function (_super) {\n    __extends(DivideAction, _super);\n    function DivideAction(args) {\n        _super.call(this, args);\n    }\n    return DivideAction;\n}(DirectionalAction));\nexports.DivideAction = DivideAction;\nvar PumpAction = (function (_super) {\n    __extends(PumpAction, _super);\n    function PumpAction(args) {\n        _super.call(this, args);\n        this.fluids = args['fluids'] || [];\n    }\n    PumpAction.prototype.mutate = function (amount) {\n        if (amount === void 0) { amount = 1; }\n        _super.prototype.mutate.call(this, amount);\n        for (var i = 0; i < this.fluids.length; ++i) {\n            var r = utils_1.Utils.getBoundedRandom(amount);\n            this.fluids[i] += r;\n        }\n    };\n    return PumpAction;\n}(DirectionalAction));\nexports.PumpAction = PumpAction;\nvar ReactAction = (function () {\n    function ReactAction(args) {\n        this.reaction = args['reaction'];\n    }\n    // mutating a react action should not change the reagents / products\n    ReactAction.prototype.mutate = function (amount) {\n        if (amount === void 0) { amount = 1; }\n    };\n    return ReactAction;\n}());\nexports.ReactAction = ReactAction;\nvar SpecializeAction = (function () {\n    function SpecializeAction(args) {\n        this.toType = args['toType'];\n    }\n    SpecializeAction.prototype.mutate = function (amount) {\n        if (amount === void 0) { amount = 1; }\n    };\n    return SpecializeAction;\n}());\nexports.SpecializeAction = SpecializeAction;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/action.ts\n ** module id = 6\n ** module chunks = 0 1\n **/","\"use strict\";\n/*\nRadian-based angles.\n*/\nvar Angle = (function () {\n    function Angle() {\n    }\n    Angle.directionDeltaRow = function (direction) {\n        if (direction == Direction.up) {\n            return -1;\n        }\n        else if (direction == Direction.down) {\n            return 1;\n        }\n        return 0;\n    };\n    Angle.directionDeltaCol = function (direction) {\n        if (direction == Direction.left) {\n            return -1;\n        }\n        else if (direction == Direction.right) {\n            return 1;\n        }\n        return 0;\n    };\n    /*\n    Return a random Direction enum based on the angle.\n    sampleDirection(0) returns Direction.RIGHT.\n    sampleDirection(Math.PI/4) is a 50-50 chance UP or RIGHT.\n    */\n    Angle.sampleDirection = function (angle) {\n        angle = Angle.canonical(angle);\n        if (angle == Angle.RIGHT)\n            return Direction.right;\n        if (angle == Angle.UP)\n            return Direction.up;\n        if (angle == Angle.LEFT)\n            return Direction.left;\n        if (angle == Angle.DOWN)\n            return Direction.down;\n        // d1, d2 specify the quadrant\n        var d1, d2;\n        if (angle > Angle.RIGHT && angle < Angle.UP) {\n            d1 = Direction.right;\n            d2 = Direction.up;\n        }\n        else if (angle > Angle.UP && angle < Angle.LEFT) {\n            d1 = Direction.up;\n            d2 = Direction.left;\n        }\n        else if (angle > Angle.LEFT && angle < Angle.DOWN) {\n            d1 = Direction.left;\n            d2 = Direction.down;\n        }\n        else {\n            d1 = Direction.down;\n            d2 = Direction.right;\n        }\n        // determine how much the angle is pointing toward d1\n        angle = angle % (Math.PI / 2);\n        var sin = Math.sin(angle), cos = Math.cos(angle);\n        if (Math.random() < cos / (sin + cos)) {\n            return d1;\n        }\n        else {\n            return d2;\n        }\n    };\n    /* Returns angle between 0 and 2 PI */\n    Angle.canonical = function (angle) {\n        angle = angle % (2 * Math.PI);\n        if (angle < 0) {\n            return angle + 2 * Math.PI;\n        }\n        return angle;\n    };\n    /*\n    Computes angle of the given (x,y) vector\n    */\n    Angle.vectorAngle = function (x, y) {\n        return Math.atan2(y, x);\n    };\n    Angle.RIGHT = 0;\n    Angle.UP = Math.PI / 2;\n    Angle.LEFT = Math.PI;\n    Angle.DOWN = 3 * Math.PI / 2;\n    return Angle;\n}());\nexports.Angle = Angle;\n/*\nCardinal direction enums\n*/\nvar Direction;\n(function (Direction) {\n    Direction[Direction[\"right\"] = 0] = \"right\";\n    Direction[Direction[\"up\"] = 1] = \"up\";\n    Direction[Direction[\"left\"] = 2] = \"left\";\n    Direction[Direction[\"down\"] = 3] = \"down\";\n})(Direction || (Direction = {}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/angle.ts\n ** module id = 7\n ** module chunks = 0 1\n **/","\"use strict\";\nvar cell_1 = require(\"./cell\");\nvar fluids_1 = require(\"./fluids\");\nvar automata_1 = require(\"./automata\");\nvar action_1 = require(\"./action\");\nvar perceptron_1 = require(\"./perceptron\");\nvar celltypes_1 = require(\"./celltypes\");\nvar DNA = (function () {\n    function DNA() {\n        window['dna'] = this;\n        this.actions = [\n            // new DivideAction({ fluidGradient: [0,0,-1,0,0,0], gravityGradient: 2 }),\n            new action_1.DivideAction({ fluidGradient: [0, 0, 0, 0, 0, 0], gravityGradient: 2 }),\n            new action_1.DivideAction({ fluidGradient: [0, 0, 0, 0, 0, 0], gravityGradient: -2 }),\n            new action_1.PumpAction({ fluidGradient: [-1, 0, 0.1, 0, 0, 0], fluids: [1, 0, 0, 0, 0, 0] }),\n            new action_1.PumpAction({ fluidGradient: [-1, 0, 0.1, 0, 0, 0], fluids: [1, 0, 0, 0, 0, 0] }),\n            // new ReactAction({ reaction: [-0.2,0.8,0.1,0,0,0] }), //photosynth\n            new action_1.ReactAction({ reaction: [0, 0, 0.1, 0, 0, 0] }),\n            new action_1.ReactAction({ reaction: [0, 0, 0, 0.1, 0, 0] }),\n            new action_1.ReactAction({ reaction: [0, 0, 0, 0, 0.1, 0] }),\n            new action_1.ReactAction({ reaction: [0, 0, 0, 0, 0, 0.1] }),\n            new action_1.ReactAction({ reaction: [0, 0, 0, -0.1, 0, 0] }),\n            new action_1.ReactAction({ reaction: [0, 0, 0, 0, -0.1, 0] }),\n            new action_1.ReactAction({ reaction: [0, 0, 0, 0, 0, -0.1] }),\n            new action_1.SpecializeAction({ toType: 0 }),\n            new action_1.SpecializeAction({ toType: 1 }),\n            new action_1.SpecializeAction({ toType: 2 }),\n            new action_1.SpecializeAction({ toType: 3 }),\n            new action_1.SpecializeAction({ toType: 4 })\n        ];\n        // cell types\n        this.cellTypes = new Array(DNA.N_CELL_TYPES);\n        for (var i = 0; i < DNA.N_CELL_TYPES; ++i) {\n            var actionPerceptrons = [];\n            for (var j = 0; j < this.actions.length; ++j) {\n                actionPerceptrons[j] = new perceptron_1.Perceptron(fluids_1.Fluids.N_FLUIDS, 8, 1);\n            }\n            this.cellTypes[i] = {\n                color: DNA.COLOR_HEX_ARRAY[i % DNA.COLOR_HEX_ARRAY.length],\n                isLeaf: i == 4,\n                cost: new fluids_1.Fluids(0.2, 0.2),\n                actionPerceptrons: actionPerceptrons\n            };\n        }\n    }\n    DNA.prototype.clone = function () {\n        var serial = DNASerializer.serialize(this);\n        return DNASerializer.deserialize(serial);\n    };\n    DNA.prototype.mutate = function (amount) {\n        if (amount === void 0) { amount = 1; }\n        // mutate actions\n        for (var i = 0; i < this.actions.length; ++i) {\n            var action = this.actions[i];\n            action.mutate(amount);\n        }\n        // mutate type controllers\n        for (var i = 0; i < this.cellTypes.length; ++i) {\n            var type = this.cellTypes[i];\n            for (var j = 0; j < type.actionPerceptrons; ++j) {\n                var p = type.actionPerceptrons[j];\n                p.perturb(amount);\n            }\n        }\n    };\n    DNA.prototype.plantSeed = function (cellArray, fluidsArray) {\n        // compute initial fluid vectors\n        var waterInitial = 20; // 1.75 * Automata.MATERIAL_WATER_WATER_MEAN;\n        var glucoseInitial = 20; // 4.0;\n        var fluids1 = new fluids_1.Fluids(waterInitial, glucoseInitial), fluids2 = new fluids_1.Fluids(waterInitial, glucoseInitial), fluids;\n        // reference coordinates\n        var rowCenterOfGrid = Math.floor(automata_1.Automata.GRID_N_ROWS / 2), colCenterOfGrid = Math.floor(automata_1.Automata.GRID_N_COLUMNS / 2), \n        // plant to create\n        plant = [], cell, \n        // iterate.\n        rowStart = rowCenterOfGrid + 2, rowEnd = rowCenterOfGrid + 10, colStart = colCenterOfGrid - 2, colEnd = colCenterOfGrid + 2;\n        for (var row = rowStart; row < rowEnd; ++row) {\n            for (var col = colStart; col < colEnd; ++col) {\n                fluids = new fluids_1.Fluids(waterInitial, glucoseInitial);\n                cell = new cell_1.Cell(this, this.cellTypes[0], fluids, row, col);\n                fluidsArray[row][col] = fluids;\n                cellArray[row][col] = cell;\n                plant.push(cell);\n            }\n        }\n        return plant;\n    };\n    DNA.N_CELL_TYPES = 5;\n    DNA.COLOR_HEX_ARRAY = [\"#ededbe\", \"#8F8F6E\", \"#6E6E8F\", \"#8F6E7F\", \"#80C4A1\"];\n    return DNA;\n}());\nexports.DNA = DNA;\n/*\nSerialization is necessary to store the results of evolution so they can be played back, saved\n*/\nvar DNASerializer = (function () {\n    function DNASerializer() {\n    }\n    DNASerializer.serialize = function (dna) {\n        var actionsSerial = new Array(dna.actions.length);\n        for (var i = 0; i < dna.actions.length; ++i) {\n            actionsSerial[i] = action_1.ActionSerializer.serialize(dna.actions[i]);\n        }\n        var cellTypesSerial = new Array(dna.cellTypes.length);\n        for (var i = 0; i < dna.cellTypes.length; ++i) {\n            cellTypesSerial[i] = celltypes_1.CellTypeSerializer.serialize(dna.cellTypes[i]);\n        }\n        return JSON.stringify({\n            cellTypes: cellTypesSerial,\n            actions: actionsSerial\n        });\n    };\n    DNASerializer.deserialize = function (serialized) {\n        var d = new DNA();\n        var o = JSON.parse(serialized);\n        var actionsSerial = o.actions;\n        var actions = new Array(actionsSerial.length);\n        for (var i = 0; i < actionsSerial.length; ++i) {\n            actions[i] = action_1.ActionSerializer.deserialize(actionsSerial[i]);\n        }\n        var cellTypesSerial = o.cellTypes;\n        var cellTypes = new Array(cellTypesSerial.length);\n        for (var i = 0; i < cellTypes.length; ++i) {\n            cellTypes[i] = celltypes_1.CellTypeSerializer.deserialize(cellTypesSerial[i]);\n        }\n        d.cellTypes = cellTypes;\n        d.actions = actions;\n        return d;\n    };\n    return DNASerializer;\n}());\nexports.DNASerializer = DNASerializer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/dna.ts\n ** module id = 8\n ** module chunks = 0 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Perceptron = (function (_super) {\n    __extends(Perceptron, _super);\n    function Perceptron() {\n        var nnodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nnodes[_i - 0] = arguments[_i];\n        }\n        _super.apply(this, nnodes);\n    }\n    Perceptron.prototype.perturb = function (amount) {\n        // perturb every weight by ~amount\n        if (amount === void 0) { amount = 1.0; }\n        // iterate through layers connections\n        var connections = this.layers.input.connectedTo[0].list\n            .concat(connections = this.layers.hidden[0].connectedTo[0].list);\n        for (var i = 0; i < connections.length; ++i) {\n            var connection = connections[i];\n            connection.weight += 2 * Math.random() * amount - amount;\n        }\n        // iterate through neurons\n        var neurons = this.layers.input.list\n            .concat(this.layers.hidden[0].list)\n            .concat(this.layers.output.list);\n        for (var i = 0; i < neurons.length; ++i) {\n            neurons[i].bias += 2 * Math.random() * amount - amount;\n        }\n        // for (var i = 0; i < this.weights.length; ++i) {\n        //     for (var j = 0; j < this.weights[i].length; ++j) {\n        //         for (var k = 0; k < this.weights[i][j].length; ++k) {\n        //             this.weights[i][j][k] += 2 * Math.random() * amount - amount;\n        //         }\n        //     }\n        // }\n    };\n    return Perceptron;\n}(Architect.Perceptron));\nexports.Perceptron = Perceptron;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/perceptron.ts\n ** module id = 9\n ** module chunks = 0 1\n **/","\"use strict\";\nvar fluids_1 = require(\"./fluids\");\nvar CellTypeSerializer = (function () {\n    function CellTypeSerializer() {\n    }\n    CellTypeSerializer.serialize = function (celltype) {\n        var perceptrons = celltype['actionPerceptrons'];\n        var perceptronsSerial = new Array(perceptrons.length);\n        for (var i = 0; i < perceptrons.length; ++i) {\n            perceptronsSerial[i] = perceptrons[i].toJSON();\n        }\n        return JSON.stringify({\n            color: celltype['color'],\n            isLeaf: celltype['isLeaf'],\n            cost: celltype['cost'].vector,\n            actionPerceptrons: perceptronsSerial\n        });\n    };\n    CellTypeSerializer.deserialize = function (serial) {\n        var obj = serial;\n        if (typeof serial === 'string') {\n            obj = JSON.parse(serial);\n        }\n        var perceptronsSerial = obj.actionPerceptrons;\n        var perceptrons = new Array(perceptronsSerial.length);\n        for (var i = 0; i < perceptronsSerial.length; ++i) {\n            perceptrons[i] = Network.fromJSON(perceptronsSerial[i]);\n        }\n        obj.actionPerceptrons = perceptrons;\n        obj.cost = new (Function.prototype.bind.apply(fluids_1.Fluids, obj.cost));\n        return obj;\n    };\n    return CellTypeSerializer;\n}());\nexports.CellTypeSerializer = CellTypeSerializer;\nvar CellType = (function () {\n    function CellType() {\n    }\n    CellType.type_up = 0;\n    CellType.type_right = 1;\n    CellType.type_rest = 2;\n    return CellType;\n}());\nexports.CellType = CellType;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/celltypes.ts\n ** module id = 10\n ** module chunks = 0 1\n **/"],"sourceRoot":""}