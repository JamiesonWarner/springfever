{"version":3,"sources":["webpack:///webpack/bootstrap 2795ea87832f3971c0e8","webpack:///./app/app.ts","webpack:///./app/simulation.ts","webpack:///./app/automata.ts","webpack:///./app/cell.ts","webpack:///./app/fluids.ts","webpack:///./app/utils.ts","webpack:///./app/dna.ts","webpack:///./app/action.ts","webpack:///./app/perceptron.ts","webpack:///./app/angle.ts","webpack:///./app/evolution.ts"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;ACrBD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD;AACA,8BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD,8BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD,8BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD,8BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA,gCAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA,wBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA,wBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA,wBAAuB,uBAAuB;AAC9C;AACA;AACA,4BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAA+D,8BAA8B;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD;AACA,8BAA6B,+BAA+B;AAC5D;AACA,gCAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC,wBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD,8BAA6B,+BAA+B;AAC5D,gCAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,8BAA8B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD,8BAA6B,+BAA+B;AAC5D;AACA;AACA,gCAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD,8BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C;AAC7C,8CAA6C;AAC7C,iDAAgD;AAChD;AACA,EAAC;AACD;;;;;;;AC3ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,uBAAuB;AACjD;AACA;AACA;AACA,2BAA0B,uBAAuB;AACjD,+BAA8B,sBAAsB,OAAO;AAC3D;AACA;AACA,2BAA0B,+BAA+B;AACzD;AACA;AACA;AACA;AACA;AACA,2BAA0B,gBAAgB;AAC1C;AACA;AACA,2BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,oBAAoB;AAC3C,4FAA2F;AAC3F;AACA;AACA;AACA;AACA,2BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACpEA;AACA;AACA;AACA;AACA,gCAA+B,uDAAuD;AACtF,kCAAiC,aAAa;AAC9C;AACA,wBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,oDAAoD;AACrF,wCAAuC,wDAAwD;AAC/F,wCAAuC,yDAAyD;AAChG;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA,4BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AC7EA;AACA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AC9DA;AACA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,cAAc;AAC9C;AACA;AACA;AACA,wBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,oBAAoB;AAC3C;AACA;AACA,2BAA0B,yBAAyB;AACnD,+BAA8B,4BAA4B;AAC1D,mCAAkC,+BAA+B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,8BAA8B;;;;;;;AClG/B;AACA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;AACA,2BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC,eAAe;AACjD;AACA;AACA;AACA,wBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC,eAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 2795ea87832f3971c0e8\n **/","\"use strict\";\nvar evolution_1 = require(\"./evolution\");\nvar angle_1 = require(\"./angle\");\ndocument.addEventListener(\"DOMContentLoaded\", function (event) {\n    var drawCanvas = document.getElementById(\"draw\");\n    // var sim = new Simulation(drawCanvas);\n    // sim.startSimulation();\n    var sim = new evolution_1.Evolution(drawCanvas);\n    var best = sim.doEvolution(0);\n    window['toggleSimulation'] = sim.toggleSimulation.bind(sim);\n    window['resetSimulation'] = function () {\n        sim.setupSimulation(null); //.bind(sim);\n        sim.startSimulation();\n    };\n    window['toggleDraw'] = sim.toggleDraw.bind(sim);\n    window['viewStyle'] = sim.viewStyle.bind(sim);\n    // sim.runForNTicks(100);\n    // DEBUG //\n    window['automata'] = sim.automata;\n    window['simulation'] = sim;\n    window['Angle'] = angle_1.Angle;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/app.ts\n ** module id = 0\n ** module chunks = 0\n **/","/*\napp.ts\n*/\n\"use strict\";\nvar automata_1 = require(\"./automata\");\nvar dna_1 = require(\"./dna\");\nvar Simulation = (function () {\n    function Simulation(drawCanvas) {\n        this.FRAME_DELAY = 1000;\n        this.drawCanvas = drawCanvas;\n        this.drawEnabled = true;\n        this.automata = new automata_1.Automata('prototype', drawCanvas);\n        this.automata.plantSeed(new dna_1.DNA());\n    }\n    Simulation.prototype.runForNTicks = function (N) {\n        // run sim for N ticks\n        for (var n = 0; n < N; ++n) {\n            this.automata.update();\n        }\n        this.automata.draw();\n    };\n    Simulation.prototype.startSimulation = function () {\n        this.isSimulationRunning = true;\n        this.updateStatus();\n        var self = this;\n        this.updateInterval = window.setInterval(function () {\n            try {\n                self.automata.update();\n            }\n            catch (e) {\n                console.warn(\"Automata error! Stopping simulation...\");\n                self.stopSimulation();\n                throw e;\n            }\n            if (self.drawEnabled) {\n                self.automata.draw();\n            }\n        }, this.FRAME_DELAY);\n        this.automata.draw();\n    };\n    Simulation.prototype.stopSimulation = function () {\n        this.showStatusString('Simulation stopped.');\n        window.clearInterval(this.updateInterval);\n        this.isSimulationRunning = false;\n    };\n    Simulation.prototype.toggleSimulation = function () {\n        if (this.isSimulationRunning)\n            this.stopSimulation();\n        else\n            this.startSimulation();\n    };\n    Simulation.prototype.setupSimulation = function (dna) {\n        if (!dna) {\n            dna = new dna_1.DNA();\n        }\n        this.showStatusString('Resetting...');\n        var view = this.automata.viewStyle;\n        this.stopSimulation();\n        this.automata = null;\n        this.automata = new automata_1.Automata('prototype', this.drawCanvas);\n        this.automata.plantSeed(dna);\n        this.automata.viewStyle = view;\n    };\n    Simulation.prototype.toggleDraw = function () {\n        this.drawEnabled = !this.drawEnabled;\n        this.updateStatus();\n    };\n    Simulation.prototype.viewStyle = function (style) {\n        console.log('viewstyle', style);\n        this.automata.viewStyle = style;\n        this.automata.draw();\n    };\n    Simulation.prototype.updateStatus = function () {\n        var status;\n        if (this.isSimulationRunning)\n            status = 'Simulation running. ';\n        else\n            status = 'Simulation stopped. ';\n        if (!this.drawEnabled)\n            status += '(Draw disabled.) ';\n        this.showStatusString(status);\n    };\n    Simulation.prototype.showStatusString = function (status) {\n        document.getElementById(\"status\").innerHTML = status;\n    };\n    return Simulation;\n}());\nexports.Simulation = Simulation;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/simulation.ts\n ** module id = 1\n ** module chunks = 0\n **/","\"use strict\";\nvar cell_1 = require(\"./cell\");\nvar fluids_1 = require(\"./fluids\");\nvar action_1 = require(\"./action\");\nvar angle_1 = require(\"./angle\");\n/*\nTODO turn Automata into systems model.\nAutomata is a place for shared state.\nAutomata just stores stuff like the fluidsArray, and its state is transformed by Systems.\n*/\nvar Automata = (function () {\n    function Automata(runString, drawCanvas) {\n        this.canvas = drawCanvas;\n        this.canvas.setAttribute('width', Automata.GRID_N_COLUMNS * Automata.CELL_SCALE_PIXELS);\n        this.canvas.setAttribute('height', Automata.GRID_N_ROWS * Automata.CELL_SCALE_PIXELS);\n        this.canvasCtx = this.canvas.getContext(\"2d\");\n        this.fluidsArray = new Array(Automata.GRID_N_ROWS);\n        for (var row = 0; row < Automata.GRID_N_ROWS; row++) {\n            this.fluidsArray[row] = new Array(Automata.GRID_N_COLUMNS);\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; ++col) {\n                // create fluid for each location in the fluids array\n                var water;\n                if (this.isDirtCell(row, col))\n                    water = Math.random() * 2 * Automata.MATERIAL_DIRT_WATER_MEAN;\n                else\n                    water = Math.random() * 2 * Automata.MATERIAL_AIR_WATER_MEAN;\n                this.fluidsArray[row][col] = new fluids_1.Fluids(water, 0);\n            }\n        }\n        this.cellArray = new Array(Automata.GRID_N_ROWS);\n        for (var row = 0; row < Automata.GRID_N_ROWS; row++) {\n            this.cellArray[row] = new Array(Automata.GRID_N_COLUMNS);\n        }\n        var self = this;\n        drawCanvas.addEventListener(\"mousemove\", function (event) {\n            self.showInfo(event.offsetX, event.offsetY);\n        });\n    }\n    Automata.prototype.plantSeed = function (seed) {\n        // remove all existing plants and add the specified seed\n        for (var row = 0; row < Automata.GRID_N_ROWS; ++row) {\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; ++col) {\n                this.cellArray[row][col] = undefined;\n            }\n        }\n        this.plant = seed.plantSeed(this.cellArray);\n        this.dna = seed;\n    };\n    Automata.prototype.isAirCell = function (row, col) {\n        return row < 50;\n    };\n    Automata.prototype.isDirtCell = function (row, col) {\n        return row >= 50;\n    };\n    Automata.prototype.printGridFluids = function () {\n        for (var row = 0; row < Automata.GRID_N_ROWS; ++row) {\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; ++col) {\n                console.log(this.fluidsArray[row][col].vector);\n            }\n        }\n    };\n    Automata.prototype.validateFluidsArray = function () {\n        for (var row = 0; row < Automata.GRID_N_ROWS; ++row) {\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; ++col) {\n                var f = this.fluidsArray[row][col].vector;\n                if (typeof f === 'undefined')\n                    console.log('row,col are: ', row, col);\n                for (var k = 0; k < f.length; ++k) {\n                    if (typeof f[k] !== 'number' || isNaN(f[k])) {\n                        throw new Error('Error: Invalid fluid vector at: ' + row + ', ' + col);\n                    }\n                    if (f[k] < 0) {\n                        console.log('Warning: Negative fluids at: ', row, col);\n                        return;\n                    }\n                }\n            }\n        }\n    };\n    Automata.prototype.showInfo = function (x, y) {\n        var tx = x / 10;\n        var ty = y / 10;\n        var row = Math.floor(ty);\n        var col = Math.floor(tx);\n        var fluids = this.fluidsArray[row][col];\n        document.getElementById('bar-water').style.width = fluids.vector[fluids_1.Fluids.WATER] + 'px';\n        document.getElementById('bar-glucose').style.width = fluids.vector[fluids_1.Fluids.GLUCOSE] + 'px';\n        document.getElementById('bar-auxin').style.width = (40 * fluids.vector[fluids_1.Fluids.AUXIN]) + 'px';\n    };\n    Automata.prototype.update = function () {\n        //console.log(\"tick\");\n        // if (this.plant.length)\n        //     console.log('cell fluids', this.plant[0].fluids.vector);\n        // Calc actions on this frame\n        var actions = new Array(this.plant.length);\n        var cell;\n        for (var i = 0; i < this.plant.length; i++) {\n            cell = this.plant[i];\n            actions[i] = cell.chooseAction();\n        }\n        // Apply actions on this frame\n        for (var i = 0; i < actions.length; i++) {\n            if (!actions[i])\n                continue;\n            var action = actions[i];\n            if (action instanceof action_1.DivideAction) {\n                // console.log(\"cell wants to grow...\")\n                var daction = action;\n                // calculate direction of this action\n                var neighborUp = this.fluidsArray[cell.row - 1][cell.col];\n                var neighborRight = this.fluidsArray[cell.row][cell.col + 1];\n                var neighborDown = this.fluidsArray[cell.row + 1][cell.col];\n                var neighborLeft = this.fluidsArray[cell.row][cell.col - 1];\n                var angle = daction.getActionDirection(neighborUp, neighborRight, neighborDown, neighborLeft);\n                var direction = angle_1.Angle.sampleDirection(angle);\n                var drow = angle_1.Angle.directionDeltaRow(direction);\n                var dcol = angle_1.Angle.directionDeltaCol(direction);\n                var gI = this.plant[i].row + drow;\n                var gJ = this.plant[i].col + dcol;\n                var cost = cell.type.cost;\n                var canAfford = true;\n                for (var j = 0; j < cost.vector.length; j++) {\n                    if (!(this.plant[i].fluids.vector[j] >= cost.vector[j])) {\n                        canAfford = false;\n                        break;\n                    }\n                }\n                if (!canAfford) {\n                    // console.log(\"cell can't afford...\")\n                    continue;\n                }\n                if (gI < 0 || gI >= Automata.GRID_N_ROWS || gJ < 0 || gJ >= Automata.GRID_N_COLUMNS) {\n                    // console.log(\"cannot make cell at \" + gJ + \", \" + gI);\n                    continue;\n                }\n                if (!(this.cellArray[gI][gJ])) {\n                    // console.log(\"growing new cell...\")\n                    this.subtractFluids(cell.fluids, cost);\n                    var newFluids = this.splitFluids(cell.fluids);\n                    var nCell = new cell_1.Cell(this.dna, cell.type, newFluids, gI, gJ);\n                    this.plant.push(nCell);\n                    this.cellArray[gI][gJ] = nCell;\n                }\n            }\n        }\n        this.fluidUpdate();\n        this.signalsUpdate();\n        this.cellDeath();\n    };\n    /*\n    Kill all cells who don't have enough resources to live\n    */\n    Automata.prototype.cellDeath = function () {\n        var MIN_WATER = 0.1 * Automata.MATERIAL_WATER_WATER_MEAN;\n        var MIN_GLUCOSE = 0.001;\n        var toKill = [];\n        for (var i = 0; i < this.plant.length; ++i) {\n            var cell = this.plant[i];\n            if (!cell.fluids)\n                continue;\n            if (cell.fluids.vector[fluids_1.Fluids.GLUCOSE] < MIN_GLUCOSE ||\n                cell.fluids.vector[fluids_1.Fluids.WATER] < MIN_WATER) {\n                // kill cell\n                toKill.push(cell);\n            }\n        }\n        for (var i = 0; i < toKill.length; ++i) {\n            var cell = toKill[i];\n            // console.log('Killing cell at: ', cell.row, cell.col);\n            var index = this.plant.indexOf(cell);\n            this.plant.splice(index, 1);\n            // this.fluidsArray[cell.row][cell.col] = cell.fluids;\n            this.cellArray[cell.row][cell.col] = undefined;\n        }\n    };\n    Automata.prototype.subtractFluids = function (a, b) {\n        for (var i = 0; i < a.vector.length; i++) {\n            a.vector[i] -= b.vector[i];\n        }\n    };\n    Automata.prototype.splitFluids = function (fluids) {\n        var newFluids = new fluids_1.Fluids();\n        for (var i = 0; i < fluids.vector.length; i++) {\n            fluids.vector[i] /= 2;\n            newFluids.vector[i] = fluids.vector[i];\n        }\n        return newFluids;\n    };\n    Automata.prototype.signalsUpdate = function () {\n        // Update each cell's individual signal levels\n        for (var i = 0; i < this.plant.length; ++i) {\n            var cell = this.plant[i];\n            cell.updateSignals();\n        }\n        // Send signals to neighbors\n        var SPREAD_COEFF = 0.1;\n        for (var i = 0; i < this.plant.length; i++) {\n            var cell = this.plant[i];\n            var neighbs = [[-1, 0], [1, 0], [0, 1], [0, -1]];\n            for (var j = 0; j < neighbs.length; j++) {\n                var nrow = cell.col + neighbs[j][0];\n                var ncol = cell.row + neighbs[j][1];\n                if (ncol < 0 || nrow < 0 || ncol >= Automata.GRID_N_COLUMNS || nrow >= Automata.GRID_N_ROWS)\n                    continue;\n                var neighbFluids = this.fluidsArray[nrow][ncol];\n                if (neighbFluids instanceof cell_1.Cell) {\n                    var nsignals = neighbFluids.vector;\n                    for (var k = fluids_1.Fluids.SIGNALS_START; k < fluids_1.Fluids.N_FLUIDS; k++) {\n                        if (cell.fluids[k] < nsignals[k])\n                            continue;\n                        var amount = SPREAD_COEFF * cell.fluids.vector[k];\n                        nsignals[k] += amount;\n                        cell.fluids.vector[k] -= amount;\n                    }\n                }\n            }\n        }\n    };\n    Automata.prototype.fluidUpdate = function () {\n        // Initialize fluidsDiff to 0's\n        var fluidsDiff = new Array(Automata.GRID_N_ROWS);\n        for (var row = 0; row < Automata.GRID_N_ROWS; row++) {\n            fluidsDiff[row] = new Array(Automata.GRID_N_COLUMNS);\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; ++col) {\n                fluidsDiff[row][col] = new Array(fluids_1.Fluids.N_FLUIDS);\n                for (var i = 0; i < fluids_1.Fluids.N_FLUIDS; ++i) {\n                    fluidsDiff[row][col][i] = 0;\n                }\n            }\n        }\n        // photosynthesis. TODO this will be an action\n        var REACTION_FACTOR = 10; // expend 1 water to get 4 glucose\n        for (var i = 0; i < this.plant.length; i++) {\n            var cell_2 = this.plant[i];\n            if (cell_2.type.isLeaf) {\n                var numAir = this.countAirNeighbors(cell_2.row, cell_2.col);\n                var dGlucose = Math.min(cell_2.fluids.vector[fluids_1.Fluids.WATER] / 4, 100 * numAir);\n                // convert water to glucose\n                fluidsDiff[cell_2.row][cell_2.col][fluids_1.Fluids.WATER] -= dGlucose;\n                fluidsDiff[cell_2.row][cell_2.col][fluids_1.Fluids.GLUCOSE] += REACTION_FACTOR * dGlucose;\n            }\n        }\n        // respiration. this is needed for stuff\n        var RESPIRATION_AMOUNT = 0.1;\n        for (var i = 0; i < this.plant.length; ++i) {\n            var cell = this.plant[i];\n            cell.fluids.vector[fluids_1.Fluids.WATER] -= RESPIRATION_AMOUNT;\n            cell.fluids.vector[fluids_1.Fluids.GLUCOSE] -= RESPIRATION_AMOUNT;\n        }\n        // Passive transport / diffusion. Give nutrients to neighbors.\n        // console.log(fluidsDiff);\n        var neighbs = [[-1, 0], [1, 0], [0, 1], [0, -1]];\n        for (var row = 0; row < Automata.GRID_N_ROWS; ++row) {\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; ++col) {\n                for (var i = 0; i < neighbs.length; ++i) {\n                    var neighbRow = row + neighbs[i][0];\n                    var neighbCol = col + neighbs[i][1];\n                    if (!this.isPositionOnGrid(neighbRow, neighbCol)) {\n                        continue;\n                    }\n                    var flowRate = 0.02;\n                    // air to air is very fast\n                    if (this.isAirNotCell(row, col) && this.isAirNotCell(neighbRow, neighbCol)) {\n                        flowRate = 0.2;\n                    }\n                    var neighbFluids = this.fluidsArray[neighbRow][neighbCol].vector;\n                    var fluids = this.fluidsArray[row][col].vector;\n                    for (var j = 0; j < fluids_1.Fluids.N_FLUIDS; ++j) {\n                        if (fluids[j] > neighbFluids[j]) {\n                            var diff = flowRate * (fluids[j] - neighbFluids[j]);\n                            fluidsDiff[row][col][j] -= diff;\n                            fluidsDiff[neighbRow][neighbCol][j] += diff;\n                        }\n                    }\n                }\n            }\n        }\n        this.validateFluidsArray();\n        // Apply fluidsDiff to fluids\n        for (var row = 0; row < Automata.GRID_N_ROWS; row++) {\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; col++) {\n                var fluids = this.fluidsArray[row][col].vector;\n                var fluidDiff = fluidsDiff[row][col];\n                for (var i = 0; i < fluids_1.Fluids.N_FLUIDS; ++i) {\n                    fluids[i] += fluidDiff[i];\n                }\n            }\n        }\n    };\n    Automata.prototype.isPositionOnGrid = function (row, col) {\n        return row >= 0 && col >= 0 &&\n            row < Automata.GRID_N_ROWS && col < Automata.GRID_N_COLUMNS;\n    };\n    Automata.prototype.isAirNotCell = function (row, col) {\n        // cell is dead and cell is air cell\n        if (!this.isPositionOnGrid(row, col))\n            return false;\n        return row < 50 && !this.cellArray[row][col];\n    };\n    Automata.prototype.countAirNeighbors = function (row, col) {\n        var n = (this.isAirNotCell(row - 1, col) ? 1 : 0) +\n            (this.isAirNotCell(row + 1, col) ? 1 : 0) +\n            (this.isAirNotCell(row, col - 1) ? 1 : 0) +\n            (this.isAirNotCell(row, col + 1) ? 1 : 0);\n        return n;\n    };\n    Automata.prototype.draw = function () {\n        if (this.validateFluidsArray()) {\n            console.log('error in fluids, skipping draw');\n            return;\n        }\n        var scale = Automata.CELL_SCALE_PIXELS;\n        this.canvasCtx.lineWidth = 3;\n        this.canvasCtx.fillStyle = \"#7EC0DD\";\n        this.canvasCtx.fillRect(0, 0, Automata.GRID_N_COLUMNS * scale, scale * Automata.GRID_N_ROWS);\n        this.canvasCtx.fillRect(0, 0, 100, 100);\n        for (var row = 0; row < Automata.GRID_N_ROWS; row++) {\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; col++) {\n                var fluids = this.fluidsArray[row][col].vector;\n                var waterContent = Math.max(Math.min(Math.round(fluids[fluids_1.Fluids.WATER]), 255), 0);\n                if (this.viewStyle === 'water') {\n                    var waterConcentration = fluids[fluids_1.Fluids.WATER] / (2 * Automata.MATERIAL_DIRT_WATER_MEAN);\n                    var waterColor = Math.max(Math.min(Math.round(255 * waterConcentration), 255), 0);\n                    var colorString = \"#\" + \"0064\" + this.getColorHex(waterColor);\n                    this.canvasCtx.fillStyle = colorString;\n                }\n                else if (this.viewStyle === 'glucose') {\n                    if (this.cellArray[row][col]) {\n                        this.canvasCtx.fillStyle = \"#\" + this.getColorHex(Math.min(255, Math.ceil(fluids[fluids_1.Fluids.GLUCOSE]))) + \"0000\";\n                    }\n                    else {\n                        this.canvasCtx.fillStyle = \"#000000\";\n                    }\n                }\n                else if (this.viewStyle === 'auxin') {\n                    var cell_3 = this.cellArray[row][col];\n                    if (cell_3) {\n                        this.canvasCtx.fillStyle = \"#\" + \"0000\" + this.getColorHex(Math.min(255, Math.ceil(255 * fluids[fluids_1.Fluids.SIGNALS_START].vector[0])));\n                    }\n                    else {\n                        this.canvasCtx.fillStyle = \"#000000\";\n                    }\n                }\n                else {\n                    var cell_4 = this.cellArray[row][col];\n                    if (cell_4) {\n                        this.canvasCtx.fillStyle = this.cellArray[row][col].type.color;\n                    }\n                    else if (row >= 50) {\n                        var cval = Math.ceil(waterContent / 4);\n                        // console.log(waterContent);\n                        this.canvasCtx.fillStyle = \"#3311\" + this.getColorHex(cval);\n                    }\n                    else {\n                        this.canvasCtx.fillStyle = \"#7EC0DD\";\n                    }\n                }\n                this.canvasCtx.fillRect(Math.floor(scale * col), Math.floor(scale * row), scale, scale);\n                // draw green outline around the plant\n                if (this.viewStyle == 'water' || this.viewStyle == 'glucose' || this.viewStyle == 'auxin') {\n                    this.canvasCtx.strokeStyle = \"#009900\";\n                    var neighbs = [[-1, 0], [1, 0], [0, 1], [0, -1]];\n                    var cell = this.cellArray[row][col];\n                    if (cell) {\n                        for (var i = 0; i < neighbs.length; ++i) {\n                            var nrow = row + neighbs[i][0];\n                            var ncol = col + neighbs[i][1];\n                            if (this.isPositionOnGrid(nrow, ncol) && !this.cellArray[nrow][ncol]) {\n                                this.canvasCtx.beginPath();\n                                if (neighbs[i][0] == -1) {\n                                    this.canvasCtx.moveTo(scale * col + 0.5, scale * row + 0.5);\n                                    this.canvasCtx.lineTo(scale * (col + 1) + 0.5, scale * row + 0.5);\n                                }\n                                else if (neighbs[i][0] == 1) {\n                                    this.canvasCtx.moveTo(scale * (col + 1) + 0.5, scale * (row + 1) + 0.5);\n                                    this.canvasCtx.lineTo(scale * col + 0.5, scale * (row + 1) + 0.5);\n                                }\n                                else if (neighbs[i][1] == -1) {\n                                    this.canvasCtx.moveTo(scale * col + 0.5, scale * (row + 1) + 0.5);\n                                    this.canvasCtx.lineTo(scale * col + 0.5, scale * row + 0.5);\n                                }\n                                else if (neighbs[i][1] == 1) {\n                                    this.canvasCtx.moveTo(scale * (col + 1) + 0.5, scale * row + 0.5);\n                                    this.canvasCtx.lineTo(scale * (col + 1) + 0.5, scale * (row + 1) + 0.5);\n                                }\n                                this.canvasCtx.stroke();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    Automata.prototype.getColorHex = function (byte) {\n        var colorString = \"\";\n        if (byte < 16) {\n            colorString += \"0\" + byte.toString(16);\n        }\n        else {\n            colorString += byte.toString(16);\n        }\n        return colorString;\n    };\n    Automata.GRID_N_COLUMNS = 120;\n    Automata.GRID_N_ROWS = 100;\n    Automata.CELL_SCALE_PIXELS = 8;\n    Automata.MATERIAL_WATER_WATER_MEAN = 1.0; // used to estimate turgidity. Wolfram Alpha: mass of 1cm^3 water\n    Automata.MATERIAL_DIRT_WATER_MEAN = 0.21; // Wolfram Alpha: mass of 1 cm^3 moist soil - Wolfram Alpha: mass of 1cm^3 dry soil;\n    Automata.MATERIAL_AIR_WATER_MEAN = 1.519e-5; // Wolfram Alpha: mass of water vapor in 1 cubic centimer air;\n    return Automata;\n}());\nexports.Automata = Automata;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/automata.ts\n ** module id = 2\n ** module chunks = 0\n **/","\"use strict\";\nvar utils_1 = require(\"./utils\");\n/*\nCell is a fleighweight object for the Grid. Systems.\nPlus they also have context for fitting into the Grid.\nIt can also be thought of as a DNA controller.\n*/\nvar Cell = (function () {\n    function Cell(dna, type, fluids, row, col) {\n        this.row = row;\n        this.col = col;\n        this.fluids = fluids;\n        if (typeof type === 'number') {\n            this.type = dna.cellTypes[type];\n        }\n        else {\n            this.type = type;\n        }\n        this.dna = dna;\n    }\n    Cell.prototype.updateSignals = function () {\n        // multiply by matrix\n        // var newSignals = new Array(Fluids.N_SIGNALS);\n        // for (var i = 0; i < newSignals.length; ++i) {\n        //     newSignals[i] = 0;\n        // }\n        // var mtx = this.type.signalMatrix;\n        // for (var i = 0; i < newSignals.length; i++) {\n        //     for (var j = 0; j < Fluids.N_SIGNALS; j++) { // first SIGNALS columns of matrix...\n        //         newSignals[i] += this.fluids.vector[j+Fluids.SIGNALS_START] * mtx[i][j];\n        //     }\n        //     for (j = 0; j < this.fluids.vector.length; ++j) {\n        //         newSignals[i] += this.fluids.vector[j] * mtx[i][j+this.signals.vector.length];\n        //     }\n        // }\n        // var vec = this.dna.cellTypes[this.type].signalB;\n        // // console.log('signals', newSignals, 'mtx', mtx, 'vec', vec);\n        // for (var i = 0; i < vec.length; i++) {\n        //     newSignals[i] += vec[i];\n        // }\n        // for (var i = 0; i < newSignals.length; i++) {\n        //     this.signals.vector[i] = Math.max(0, Math.min(1, newSignals[i]));\n        // }\n    };\n    Cell.prototype.getActionPotential = function (action) {\n        return 0;\n    };\n    Cell.prototype.chooseAction = function () {\n        // var signals = this.signals,\n        //     cellType = this.type;\n        // var perceptron = this.type.\n        // Calculate which actions have high potential values\n        var actions = this.dna.actions;\n        var potentials = new Array(actions.length);\n        for (var i = 0; i < actions.length; ++i) {\n            potentials[i] = this.type.actionPerceptrons[i].activate(this.fluids.vector)[0]; // this.getActionPotential(actions[i]);\n        }\n        var bestIndex = utils_1.Utils.argmax(potentials);\n        // console.log('choosing action, ', actions[bestIndex]);\n        return actions[bestIndex];\n        // for (var i = 0; i < activators.length; ++i) {\n        //     activators[i] = this.activatorFunction(this.distanceToActivator(signals, actions[i].activator));\n        // }\n        // // console.log('activators', activators, 'actions', actions);\n        // return this.weightedChoose(actions, activators);\n    };\n    return Cell;\n}());\nexports.Cell = Cell;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/cell.ts\n ** module id = 3\n ** module chunks = 0\n **/","\"use strict\";\nvar automata_1 = require(\"./automata\");\nvar Fluids = (function () {\n    function Fluids(water, glucose) {\n        if (water === void 0) { water = automata_1.Automata.MATERIAL_WATER_WATER_MEAN; }\n        if (glucose === void 0) { glucose = 0; }\n        this.vector = new Array(Fluids.N_FLUIDS);\n        for (var i = 0; i < Fluids.N_FLUIDS; ++i) {\n            this.vector[i] = 0;\n        }\n        this.vector[Fluids.WATER] = water;\n        this.vector[Fluids.GLUCOSE] = glucose;\n    }\n    Fluids.prototype.sumFluids = function () {\n        var s = 0;\n        for (var i = 0; i < this.vector.length; ++i) {\n            s += this.vector[i];\n        }\n        return s;\n    };\n    Fluids.prototype.getPressureInArea = function (area) {\n        return this.sumFluids() / area;\n    };\n    /*\n    Goal:  q\n    */\n    /*\n    Returns the quantity of a given fluid, which is the amount of a substance per unit volume.\n    divided by the total fluid.\n\n    */\n    /*\n\n    */\n    Fluids.prototype.getFluidConcentration = function (fluidId, area) {\n    };\n    /*\n    Diffusive flux is rate of flow per unit area. Positive value means outward flow.\n\n    Fick's law of diffusion: J = -D (d phi)/(d x)\n    J is diffusive flux\n    D is diffusion coefficient\n    phi is amount of\n    x is position\n    */\n    Fluids.prototype.getDiffusiveFlux = function (toFluid, area1, area2) { };\n    Fluids.WATER = 0;\n    Fluids.GLUCOSE = 1;\n    Fluids.AUXIN = 2;\n    Fluids.SIGNALS_START = 2;\n    Fluids.N_SIGNALS = 4;\n    Fluids.N_FLUIDS = 2 + Fluids.N_SIGNALS;\n    return Fluids;\n}());\nexports.Fluids = Fluids;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/fluids.ts\n ** module id = 4\n ** module chunks = 0\n **/","\"use strict\";\nvar Utils = (function () {\n    function Utils() {\n    }\n    Utils.crossProduct = function (arr1, arr2) {\n        var sum = 0;\n        var length = Math.min(arr1.length, arr2.length);\n        for (var i = 0; i < length; ++i) {\n            sum += arr1[i] * arr2[i];\n        }\n        return sum;\n    };\n    Utils.l2norm = function (arr) {\n        var n = 0;\n        for (var i = 0; i < arr.length; ++i) {\n            n += arr[i] * arr[i];\n        }\n        return Math.sqrt(n);\n    };\n    Utils.l1norm = function (arr) {\n        var n = 0;\n        for (var i = 0; i < arr.length; ++i) {\n            n += arr[i];\n        }\n        return n;\n    };\n    Utils.distanceToPlane = function (fluids, activator) {\n        var normW = Utils.l2norm(activator.w);\n        var d = 0;\n        for (var i = 0; i < length; ++i) {\n            d += fluids[i] * activator[i];\n        }\n        d += activator.b;\n        return d / normW;\n    };\n    /*\n    Sigmoid activator.\n    Returns value from 0 to 1 given f from -inf to inf.\n    */\n    Utils.activatorFunction = function (v) {\n        return 1 / (1 + Math.exp(-v));\n    };\n    Utils.argmax = function (arr) {\n        if (!arr.length)\n            return undefined;\n        var max = arr[0];\n        var argmax = 0;\n        for (var i = 1; i < arr.length; ++i) {\n            if (arr[i] > max) {\n                argmax = i;\n                max = arr[i];\n            }\n        }\n        return argmax;\n    };\n    return Utils;\n}());\nexports.Utils = Utils;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/utils.ts\n ** module id = 5\n ** module chunks = 0\n **/","\"use strict\";\nvar cell_1 = require(\"./cell\");\nvar fluids_1 = require(\"./fluids\");\nvar automata_1 = require(\"./automata\");\nvar action_1 = require(\"./action\");\nvar perceptron_1 = require(\"./perceptron\");\nvar DNA = (function () {\n    function DNA() {\n        window['dna'] = this;\n        this.actions = [\n            // new DivideAction({ fluidGradient: [0,0,-1,0,0,0], gravityGradient: 2 }),\n            new action_1.DivideAction({ fluidGradient: [0, 0, 0, 0, 0, 0], gravityGradient: 2 }),\n            new action_1.DivideAction({ fluidGradient: [0, 0, 0, 0, 0, 0], gravityGradient: -2 }),\n        ];\n        // cell types\n        this.cellTypes = new Array(DNA.N_CELL_TYPES);\n        for (var i = 0; i < DNA.N_CELL_TYPES; ++i) {\n            var actionPerceptrons = [];\n            for (var j = 0; j < this.actions.length; ++j) {\n                actionPerceptrons[j] = new perceptron_1.Perceptron(fluids_1.Fluids.N_FLUIDS, 8, 1);\n            }\n            this.cellTypes[i] = {\n                color: DNA.COLOR_HEX_ARRAY[i % DNA.COLOR_HEX_ARRAY.length],\n                isLeaf: i == 1,\n                cost: new fluids_1.Fluids(0.2, 0.2),\n                actionPerceptrons: actionPerceptrons\n            };\n        }\n    }\n    DNA.prototype.copyAndMutate = function (amount) {\n        if (amount === void 0) { amount = 1; }\n        return new DNA();\n    };\n    DNA.prototype.plantSeed = function (grid) {\n        var waterInitial = 1.75 * automata_1.Automata.MATERIAL_WATER_WATER_MEAN;\n        var glucoseInitial = 4.0;\n        var rowCenter = Math.floor(automata_1.Automata.GRID_N_ROWS / 2), colCenter = Math.floor(automata_1.Automata.GRID_N_COLUMNS / 2), row1 = rowCenter + 2, row2 = rowCenter + 3, col1 = colCenter, col2 = colCenter;\n        var c1 = new cell_1.Cell(this, 0, new fluids_1.Fluids(waterInitial, glucoseInitial), row1, col1), c2 = new cell_1.Cell(this, 1, new fluids_1.Fluids(waterInitial, glucoseInitial), row2, col2);\n        var seed = [c1, c2];\n        grid[c1.row][c1.col] = c1;\n        grid[c2.row][c2.col] = c2;\n        return seed;\n    };\n    /*\n  In nature, the gene controls the transcription product, and .\n  \n  \n  Inputs of a cell:\n  - Fluids\n  - Fluids gradient...\n  \n  Actions of a cell:\n  \n  DNA is a list of potential actions:\n  - Reproduce (directional), direction specified as vector multiplier of fluids\n  - Pump fluids (directional), direction specified as vector multiplier of fluids\n  - Reactions\n  - Specialize\n  \n  CellType is the controller of DNA and determines when gene products are made.\n  Each cell type is also a 2 layer neural net, which takes as input the fluid vector.\n  Each cell type has a list of potential actions, which may be paramaterized by neighbor states.\n  Transitions between cell types can be modeled as a markov chain, though some states are unreachable once left.\n    */\n    /*\n    For every action, celltypes has a neural net\n    */\n    DNA.prototype.serialize = function () {\n        return {\n            cellTypes: this.cellTypes,\n            actions: this.actions\n        };\n    };\n    DNA.N_CELL_TYPES = 2;\n    DNA.COLOR_HEX_ARRAY = [\"#ededbe\", \"#8F8F6E\", \"#6E6E8F\", \"#8F6E7F\", \"#80C4A1\"];\n    return DNA;\n}());\nexports.DNA = DNA;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/dna.ts\n ** module id = 6\n ** module chunks = 0\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar utils_1 = require(\"./utils\");\nvar DirectionalAction = (function () {\n    function DirectionalAction(args) {\n        this.fluidGradient = args['fluidGradient'];\n        this.gravityGradient = args['gravityGradient'];\n        this.sunGradient = args['sunGradient'];\n    }\n    DirectionalAction.prototype.getActionDirection = function (upFluids, rightFluids, downFluids, leftFluids) {\n        var upContribution = utils_1.Utils.crossProduct(upFluids, this.fluidGradient);\n        var rightContribution = utils_1.Utils.crossProduct(rightFluids, this.fluidGradient);\n        var downContribution = utils_1.Utils.crossProduct(downFluids, this.fluidGradient);\n        var leftContribution = utils_1.Utils.crossProduct(leftFluids, this.fluidGradient);\n        if (this.gravityGradient) {\n            downContribution += this.gravityGradient;\n        }\n        var direction = Math.atan2(upContribution - downContribution, rightContribution - leftContribution);\n        console.log('calculated action direction is ', direction, upContribution, downContribution);\n        return direction;\n    };\n    /*\n    Calculate the angle that this action points to\n    */\n    DirectionalAction.prototype.getGradientToFluids = function () {\n    };\n    return DirectionalAction;\n}());\nexports.DirectionalAction = DirectionalAction;\nvar DivideAction = (function (_super) {\n    __extends(DivideAction, _super);\n    function DivideAction(args) {\n        _super.call(this, args);\n    }\n    return DivideAction;\n}(DirectionalAction));\nexports.DivideAction = DivideAction;\nvar PumpAction = (function (_super) {\n    __extends(PumpAction, _super);\n    function PumpAction(args) {\n        _super.call(this, args);\n    }\n    return PumpAction;\n}(DirectionalAction));\nexports.PumpAction = PumpAction;\nvar ReactAction = (function () {\n    function ReactAction(args) {\n        this.reaction = args['reaction'];\n    }\n    return ReactAction;\n}());\nexports.ReactAction = ReactAction;\nvar SpecializeAction = (function () {\n    function SpecializeAction(args) {\n        this.toType = args['toType'];\n    }\n    return SpecializeAction;\n}());\nexports.SpecializeAction = SpecializeAction;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/action.ts\n ** module id = 7\n ** module chunks = 0\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Perceptron = (function (_super) {\n    __extends(Perceptron, _super);\n    function Perceptron() {\n        var nnodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nnodes[_i - 0] = arguments[_i];\n        }\n        _super.apply(this, nnodes);\n    }\n    Perceptron.prototype.perturb = function (amount) {\n        // perturb every weight by ~amount\n        if (amount === void 0) { amount = 1.0; }\n        // iterate through layers connections\n        var connections = this.layers.input.connectedTo[0].list\n            .concat(connections = this.layers.hidden[0].connectedTo[0].list);\n        for (var i = 0; i < connections.length; ++i) {\n            var connection = connections[i];\n            connection.weight += 2 * Math.random() * amount - amount;\n        }\n        // iterate through neurons\n        var neurons = this.layers.input.list\n            .concat(this.layers.hidden[0].list)\n            .concat(this.layers.output.list);\n        for (var i = 0; i < neurons.length; ++i) {\n            neurons[i].bias += 2 * Math.random() * amount - amount;\n        }\n        // for (var i = 0; i < this.weights.length; ++i) {\n        //     for (var j = 0; j < this.weights[i].length; ++j) {\n        //         for (var k = 0; k < this.weights[i][j].length; ++k) {\n        //             this.weights[i][j][k] += 2 * Math.random() * amount - amount;\n        //         }\n        //     }\n        // }\n    };\n    return Perceptron;\n}(Architect.Perceptron));\nexports.Perceptron = Perceptron;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/perceptron.ts\n ** module id = 8\n ** module chunks = 0 1\n **/","\"use strict\";\n/*\nRadian-based angles.\n*/\nvar Angle = (function () {\n    function Angle() {\n    }\n    Angle.directionDeltaRow = function (direction) {\n        if (direction == Direction.up) {\n            return -1;\n        }\n        else if (direction == Direction.down) {\n            return 1;\n        }\n        return 0;\n    };\n    Angle.directionDeltaCol = function (direction) {\n        if (direction == Direction.left) {\n            return -1;\n        }\n        else if (direction == Direction.right) {\n            return 1;\n        }\n        return 0;\n    };\n    /*\n    Return a random Direction enum based on the angle.\n    sampleDirection(0) returns Direction.RIGHT.\n    sampleDirection(Math.PI/4) is a 50-50 chance UP or RIGHT.\n    */\n    Angle.sampleDirection = function (angle) {\n        angle = Angle.canonical(angle);\n        if (angle == Angle.RIGHT)\n            return Direction.right;\n        if (angle == Angle.UP)\n            return Direction.up;\n        if (angle == Angle.LEFT)\n            return Direction.left;\n        if (angle == Angle.DOWN)\n            return Direction.down;\n        // d1, d2 specify the quadrant\n        var d1, d2;\n        if (angle > Angle.RIGHT && angle < Angle.UP) {\n            d1 = Direction.right;\n            d2 = Direction.up;\n        }\n        else if (angle > Angle.UP && angle < Angle.LEFT) {\n            d1 = Direction.up;\n            d2 = Direction.left;\n        }\n        else if (angle > Angle.LEFT && angle < Angle.DOWN) {\n            d1 = Direction.left;\n            d2 = Direction.down;\n        }\n        else {\n            d1 = Direction.down;\n            d2 = Direction.right;\n        }\n        // determine how much the angle is pointing toward d1\n        angle = angle % (Math.PI / 2);\n        var sin = Math.sin(angle), cos = Math.cos(angle);\n        if (Math.random() < cos / (sin + cos)) {\n            return d1;\n        }\n        else {\n            return d2;\n        }\n    };\n    /* Returns angle between 0 and 2 PI */\n    Angle.canonical = function (angle) {\n        angle = angle % (2 * Math.PI);\n        if (angle < 0) {\n            return angle + 2 * Math.PI;\n        }\n        return angle;\n    };\n    /*\n    Computes angle of the given (x,y) vector\n    */\n    Angle.vectorAngle = function (x, y) {\n        return Math.atan2(y, x);\n    };\n    Angle.RIGHT = 0;\n    Angle.UP = Math.PI / 2;\n    Angle.LEFT = Math.PI;\n    Angle.DOWN = 3 * Math.PI / 2;\n    return Angle;\n}());\nexports.Angle = Angle;\n/*\nCardinal direction enums\n*/\nvar Direction;\n(function (Direction) {\n    Direction[Direction[\"right\"] = 0] = \"right\";\n    Direction[Direction[\"up\"] = 1] = \"up\";\n    Direction[Direction[\"left\"] = 2] = \"left\";\n    Direction[Direction[\"down\"] = 3] = \"down\";\n})(Direction || (Direction = {}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/angle.ts\n ** module id = 9\n ** module chunks = 0\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar dna_1 = require(\"./dna\");\nvar simulation_1 = require(\"./simulation\");\nvar Evolution = (function (_super) {\n    __extends(Evolution, _super);\n    function Evolution(drawCanvas) {\n        _super.call(this, drawCanvas);\n        this.generation = 0;\n    }\n    Evolution.prototype.doEvolution = function (ngenerations, seed) {\n        if (ngenerations === void 0) { ngenerations = 4; }\n        if (!seed) {\n            seed = new dna_1.DNA();\n        }\n        // this.FRAME_DELAY = 20;\n        // for (var i = 0; i < length; ++i) {\n        //     var mutated = seed.copyAndMutate();\n        //     this.runForNTicks(5);\n        //     // code...\n        // }\n        // this.setupSimulation(mutated);\n        // return seed;\n        var best = seed;\n        // for (var i = 0; i < ngenerations; ++i) {\n        best = this.runGenerationSelectBest(10, best, 4);\n        // }\n        return best;\n    };\n    Evolution.prototype.runGenerationSelectBest = function (nchildren, seed, growtime) {\n        // grow the seed for growtime iterations, then eval its fitness\n        if (growtime === void 0) { growtime = 40; }\n        // generate random children\n        var children = new Array(nchildren);\n        // make n copies of the dna\n        for (var i = 0; i < nchildren; ++i) {\n            children[i] = seed.copyAndMutate();\n        }\n        // evaluate each one's fitness\n        var fitness = new Array(nchildren);\n        var i = 0;\n        var self = this;\n        window.setInterval(function () {\n            // this function will return immediately and then run grow on all children\n            self.runGenerationSelectBestHelper(nchildren, seed, growtime, children, fitness, i);\n            self.generation++;\n            self.updateStatus();\n            i++;\n        }, this.FRAME_DELAY);\n        window['fitness'] = fitness;\n        window['children'] = children;\n        return null;\n    };\n    Evolution.prototype.updateStatus = function () {\n        var status;\n        if (this.isSimulationRunning)\n            status = 'Simulation running. ';\n        else\n            status = 'Simulation stopped. ';\n        if (!this.drawEnabled)\n            status += '(Draw disabled.) ';\n        status += \"Generation \" + this.generation + \". \";\n        this.showStatusString(status);\n    };\n    /* Recursive function */\n    Evolution.prototype.runGenerationSelectBestHelper = function (nchildren, seed, growtime, children, fitness, child_index) {\n        if (growtime === void 0) { growtime = 40; }\n        this.setupSimulation(children[child_index]);\n        this.runForNTicks(growtime);\n        fitness[child_index] = this.evalFitness(this.automata.plant);\n        // Recursive call on the next animation frame\n        // if (child_index + 1 < nchildren) {\n        //     var self = this;\n        //     requestAnimationFrame(function() {\n        //         self.runGenerationSelectBestHelper(nchildren, seed, growtime, children, fitness, child_index + 1);\n        //     })\n        // }\n    };\n    Evolution.prototype.evalFitness = function (plant) {\n        return plant.length;\n    };\n    return Evolution;\n}(simulation_1.Simulation));\nexports.Evolution = Evolution;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/evolution.ts\n ** module id = 10\n ** module chunks = 0\n **/"],"sourceRoot":""}