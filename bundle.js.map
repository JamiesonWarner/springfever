{"version":3,"sources":["webpack:///webpack/bootstrap f9acb6c2c621be6b3823","webpack:///./app/app.ts","webpack:///./app/simulation.ts","webpack:///./app/automata.ts","webpack:///./app/dna.ts","webpack:///./app/cell.ts","webpack:///./app/fluids.ts","webpack:///./app/angle.ts"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;ACfD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD;AACA,8BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD;AACA,8BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,0BAAyB,4BAA4B;AACrD,8BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD,8BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA,gCAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA,wBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA,wBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA,wBAAuB,uBAAuB;AAC9C;AACA;AACA,4BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAA+D,8BAA8B;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD;AACA,8BAA6B,+BAA+B;AAC5D;AACA,gCAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC,wBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD,8BAA6B,+BAA+B;AAC5D,gCAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,8BAA8B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD,8BAA6B,+BAA+B;AAC5D;AACA;AACA,gCAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,4BAA4B;AACrD,8BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AC1YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACvYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,uBAAuB;AACjD;AACA;AACA;AACA,2BAA0B,uBAAuB;AACjD,+BAA8B,sBAAsB,OAAO;AAC3D;AACA;AACA,2BAA0B,+BAA+B;AACzD;AACA;AACA;AACA;AACA;AACA,2BAA0B,gBAAgB;AAC1C;AACA;AACA,2BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AC/DA;AACA;AACA;AACA,gCAA+B,aAAa;AAC5C,kCAAiC,aAAa;AAC9C;AACA,wBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap f9acb6c2c621be6b3823\n **/","\"use strict\";\nvar simulation_1 = require(\"./simulation\");\nvar angle_1 = require(\"./angle\");\ndocument.addEventListener(\"DOMContentLoaded\", function (event) {\n    var drawCanvas = document.getElementById(\"draw\");\n    var sim = new simulation_1.Simulation(drawCanvas);\n    window['toggleSimulation'] = sim.toggleSimulation.bind(sim);\n    window['resetSimulation'] = sim.resetSimulation.bind(sim);\n    window['toggleDraw'] = sim.toggleDraw.bind(sim);\n    window['viewStyle'] = sim.viewStyle.bind(sim);\n    // sim.runForNTicks(100);\n    // DEBUG //\n    window['automata'] = sim.automata;\n    window['simulation'] = sim;\n    window['Angle'] = angle_1.Angle;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/app.ts\n ** module id = 0\n ** module chunks = 0\n **/","/*\napp.ts\n*/\n\"use strict\";\nvar automata_1 = require(\"./automata\");\nvar Simulation = (function () {\n    function Simulation(drawCanvas) {\n        this.FRAME_DELAY = 20;\n        this.drawCanvas = drawCanvas;\n        this.drawEnabled = true;\n        this.automata = new automata_1.Automata('prototype', drawCanvas);\n        this.startSimulation();\n    }\n    Simulation.prototype.runForNTicks = function (N) {\n        // run sim for N ticks\n        for (var n = 0; n < N; ++n) {\n            this.automata.update();\n        }\n        this.automata.draw();\n    };\n    Simulation.prototype.startSimulation = function () {\n        this.isSimulationRunning = true;\n        this.updateStatus();\n        var self = this;\n        this.updateInterval = window.setInterval(function () {\n            try {\n                self.automata.update();\n            }\n            catch (e) {\n                console.warn(\"Automata error! Stopping simulation...\");\n                self.stopSimulation();\n                throw e;\n            }\n            if (self.drawEnabled) {\n                self.automata.draw();\n            }\n        }, this.FRAME_DELAY);\n    };\n    Simulation.prototype.stopSimulation = function () {\n        this.showStatusString('Simulation stopped.');\n        window.clearInterval(this.updateInterval);\n        this.isSimulationRunning = false;\n    };\n    Simulation.prototype.toggleSimulation = function () {\n        if (this.isSimulationRunning)\n            this.stopSimulation();\n        else\n            this.startSimulation();\n    };\n    Simulation.prototype.resetSimulation = function () {\n        this.showStatusString('Resetting...');\n        var view = this.automata.viewStyle;\n        this.stopSimulation();\n        this.automata = null;\n        this.automata = new automata_1.Automata('prototype', this.drawCanvas);\n        this.automata.viewStyle = view;\n        this.startSimulation();\n    };\n    Simulation.prototype.toggleDraw = function () {\n        this.drawEnabled = !this.drawEnabled;\n        this.updateStatus();\n    };\n    Simulation.prototype.viewStyle = function (style) {\n        console.log('viewstyle', style);\n        this.automata.viewStyle = style;\n        this.automata.draw();\n    };\n    Simulation.prototype.updateStatus = function () {\n        var status;\n        if (this.isSimulationRunning)\n            status = 'Simulation running. ';\n        else\n            status = 'Simulation stopped. ';\n        if (!this.drawEnabled)\n            status += '(Draw disabled.) ';\n        this.showStatusString(status);\n    };\n    Simulation.prototype.showStatusString = function (status) {\n        document.getElementById(\"status\").innerHTML = status;\n    };\n    return Simulation;\n}());\nexports.Simulation = Simulation;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/simulation.ts\n ** module id = 1\n ** module chunks = 0\n **/","\"use strict\";\nvar dna_1 = require(\"./dna\");\nvar cell_1 = require(\"./cell\");\nvar fluids_1 = require(\"./fluids\");\n/*\nTODO turn Automata into systems model.\nAutomata just stores stuff like the fluidsArray, and its state is transformed by Systems.\n*/\nvar Automata = (function () {\n    function Automata(runString, drawCanvas) {\n        this.drawWater = false;\n        var dna = new dna_1.DNA();\n        this.dna = dna;\n        this.canvas = drawCanvas;\n        this.canvas.setAttribute('width', Automata.GRID_N_COLUMNS * Automata.CELL_SCALE_PIXELS);\n        this.canvas.setAttribute('height', Automata.GRID_N_ROWS * Automata.CELL_SCALE_PIXELS);\n        this.canvasCtx = this.canvas.getContext(\"2d\");\n        this.fluidsArray = new Array(Automata.GRID_N_ROWS);\n        for (var row = 0; row < Automata.GRID_N_ROWS; row++) {\n            this.fluidsArray[row] = new Array(Automata.GRID_N_COLUMNS);\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; ++col) {\n                var water = this.isAirCell(row, col) ? 100 * Math.random() : 500 * Math.random();\n                this.fluidsArray[row][col] = new fluids_1.Fluids(water, 0);\n            }\n        }\n        this.cellArray = new Array(Automata.GRID_N_ROWS);\n        for (var row = 0; row < Automata.GRID_N_ROWS; row++) {\n            this.cellArray[row] = new Array(Automata.GRID_N_COLUMNS);\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; ++col) {\n                var water = this.isAirCell(row, col) ? 100 * Math.random() : 500 * Math.random();\n                this.cellArray[row][col] = undefined;\n            }\n        }\n        this.plant = dna.plantSeed(this.cellArray);\n        var self = this;\n        drawCanvas.addEventListener(\"mousemove\", function (event) {\n            self.showInfo(event.offsetX, event.offsetY);\n        });\n    }\n    Automata.prototype.printGridFluids = function () {\n        for (var row = 0; row < Automata.GRID_N_ROWS; ++row) {\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; ++col) {\n                console.log(this.fluidsArray[row][col].vector);\n            }\n        }\n    };\n    Automata.prototype.validateFluidsArray = function () {\n        for (var row = 0; row < Automata.GRID_N_ROWS; ++row) {\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; ++col) {\n                var f = this.fluidsArray[row][col].vector;\n                if (typeof f === 'undefined')\n                    console.log('row,col are: ', row, col);\n                for (var k = 0; k < f.length; ++k) {\n                    if (typeof f[k] !== 'number' || isNaN(f[k])) {\n                        throw new Error('Error: Invalid fluid vector at: ' + row + ', ' + col);\n                    }\n                    if (f[k] < 0) {\n                        console.log('Warning: Negative fluids at: ', row, col);\n                        return;\n                    }\n                }\n            }\n        }\n    };\n    Automata.prototype.showInfo = function (x, y) {\n        var tx = x / 10;\n        var ty = y / 10;\n        var row = Math.floor(ty);\n        var col = Math.floor(tx);\n        var fluids = this.fluidsArray[row][col];\n        document.getElementById('bar-water').style.width = fluids.vector[fluids_1.Fluids.WATER] + 'px';\n        document.getElementById('bar-glucose').style.width = fluids.vector[fluids_1.Fluids.GLUCOSE] + 'px';\n        document.getElementById('bar-auxin').style.width = (40 * fluids.vector[fluids_1.Fluids.AUXIN]) + 'px';\n    };\n    Automata.prototype.update = function () {\n        //console.log(\"tick\");\n        // Calc actions on this frame\n        var actions = new Array(this.plant.length);\n        for (var i = 0; i < this.plant.length; i++) {\n            var cell = this.plant[i];\n            cell.update();\n            actions[i] = cell.getAction();\n        }\n        // Apply actions on this frame\n        for (var i = 0; i < actions.length; i++) {\n            if (!actions[i])\n                continue;\n            var action = actions[i];\n            if (action.name === \"grow\") {\n                // console.log(\"cell wants to grow...\")\n                var drow = 0;\n                var dcol = 0;\n                if (action.parameters.direction === \"up\") {\n                    drow = -1;\n                }\n                else if (action.parameters.direction === \"down\") {\n                    drow = 1;\n                }\n                else if (action.parameters.direction === \"right\") {\n                    dcol = 1;\n                }\n                else if (action.parameters.direction === \"left\") {\n                    dcol = -1;\n                }\n                var gI = this.plant[i].row + drow;\n                var gJ = this.plant[i].col + dcol;\n                var cost = this.dna.cellTypes[action.parameters.type].cost;\n                var canAfford = true;\n                for (var j = 0; j < cost.vector.length; j++) {\n                    if (!(this.plant[i].fluids.vector[j] >= cost.vector[j])) {\n                        canAfford = false;\n                        break;\n                    }\n                }\n                if (!canAfford) {\n                    // console.log(\"cell can't afford...\")\n                    continue;\n                }\n                if (gI < 0 || gI >= Automata.GRID_N_ROWS || gJ < 0 || gJ >= Automata.GRID_N_COLUMNS) {\n                    // console.log(\"cannot make cell at \" + gJ + \", \" + gI);\n                    continue;\n                }\n                if (!(this.cellArray[gI][gJ])) {\n                    // console.log(\"growing new cell...\")\n                    this.subtractFluids(this.plant[i].fluids, cost);\n                    var newFluids = this.splitFluids(this.plant[i]);\n                    var nCell = new cell_1.Cell(this.dna, action.parameters.type, newFluids, gI, gJ);\n                    this.plant.push(nCell);\n                    this.cellArray[gI][gJ] = nCell;\n                }\n            }\n        }\n        this.fluidUpdate();\n        this.signalsUpdate();\n        this.cellDeath();\n    };\n    /*\n    Kill all cells who don't have enough resources to live\n    */\n    Automata.prototype.cellDeath = function () {\n        var MIN_WATER = 10;\n        var MIN_GLUCOSE = 10;\n        var toKill = [];\n        for (var i = 0; i < this.plant.length; ++i) {\n            var cell = this.plant[i];\n            if (!cell.fluids)\n                continue;\n            if (cell.fluids.vector[fluids_1.Fluids.GLUCOSE] < MIN_GLUCOSE ||\n                cell.fluids.vector[fluids_1.Fluids.WATER] < MIN_WATER) {\n                // kill cell\n                toKill.push(cell);\n            }\n        }\n        for (var i = 0; i < toKill.length; ++i) {\n            var cell = toKill[i];\n            // console.log('Killing cell at: ', cell.row, cell.col);\n            var index = this.plant.indexOf(cell);\n            this.plant.splice(index, 1);\n            // this.fluidsArray[cell.row][cell.col] = cell.fluids;\n            this.cellArray[cell.row][cell.col] = undefined;\n        }\n    };\n    Automata.prototype.subtractFluids = function (a, b) {\n        for (var i = 0; i < a.vector.length; i++) {\n            a.vector[i] -= b.vector[i];\n        }\n    };\n    Automata.prototype.splitFluids = function (cell) {\n        var newFluids = new fluids_1.Fluids(0);\n        for (var i = 0; i < cell.fluids.vector.length; i++) {\n            cell.fluids.vector[i] /= 2;\n            newFluids.vector[i] = cell.fluids.vector[i];\n        }\n        return newFluids;\n    };\n    Automata.prototype.signalsUpdate = function () {\n        // Update each cell's individual signal levels\n        for (var i = 0; i < this.plant.length; ++i) {\n            var cell = this.plant[i];\n            cell.updateSignals();\n        }\n        // Send signals to neighbors\n        var SPREAD_COEFF = 0.1;\n        for (var i = 0; i < this.plant.length; i++) {\n            var cell = this.plant[i];\n            var neighbs = [[-1, 0], [1, 0], [0, 1], [0, -1]];\n            for (var j = 0; j < neighbs.length; j++) {\n                var nrow = cell.col + neighbs[j][0];\n                var ncol = cell.row + neighbs[j][1];\n                if (ncol < 0 || nrow < 0 || ncol >= Automata.GRID_N_COLUMNS || nrow >= Automata.GRID_N_ROWS)\n                    continue;\n                var neighbFluids = this.fluidsArray[nrow][ncol];\n                if (neighbFluids instanceof cell_1.Cell) {\n                    var nsignals = neighbFluids.vector;\n                    for (var k = fluids_1.Fluids.SIGNALS_START; k < fluids_1.Fluids.N_FLUIDS; k++) {\n                        if (cell.fluids[k] < nsignals[k])\n                            continue;\n                        var amount = SPREAD_COEFF * cell.fluids.vector[k];\n                        nsignals[k] += amount;\n                        cell.fluids.vector[k] -= amount;\n                    }\n                }\n            }\n        }\n    };\n    Automata.prototype.fluidUpdate = function () {\n        // Initialize fluidsDiff to 0's\n        var fluidsDiff = new Array(Automata.GRID_N_ROWS);\n        for (var row = 0; row < Automata.GRID_N_ROWS; row++) {\n            fluidsDiff[row] = new Array(Automata.GRID_N_COLUMNS);\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; ++col) {\n                fluidsDiff[row][col] = new Array(fluids_1.Fluids.N_FLUIDS);\n                for (var i = 0; i < fluids_1.Fluids.N_FLUIDS; ++i) {\n                    fluidsDiff[row][col][i] = 0;\n                }\n            }\n        }\n        // photosynthesis. TODO this will be an action\n        var REACTION_FACTOR = 10; // expend 1 water to get 4 glucose\n        for (var i = 0; i < this.plant.length; i++) {\n            var cell = this.plant[i];\n            if (cell.type.isLeaf) {\n                var numAir = this.countAirNeighbors(cell.row, cell.col);\n                var dGlucose = Math.min(cell.fluids.vector[fluids_1.Fluids.WATER] / 4, 100 * numAir);\n                // convert water to glucose\n                fluidsDiff[cell.row][cell.col][fluids_1.Fluids.WATER] -= dGlucose;\n                fluidsDiff[cell.row][cell.col][fluids_1.Fluids.GLUCOSE] += REACTION_FACTOR * dGlucose;\n            }\n        }\n        // respiration. this is needed for stuff\n        var RESPIRATION_AMOUNT = 0.1;\n        for (var i = 0; i < this.plant.length; ++i) {\n            var cell = this.plant[i];\n            cell.fluids.vector[fluids_1.Fluids.WATER] -= RESPIRATION_AMOUNT;\n            cell.fluids.vector[fluids_1.Fluids.GLUCOSE] -= RESPIRATION_AMOUNT;\n        }\n        // Passive transport / diffusion. Give nutrients to neighbors.\n        var neighbs = [[-1, 0], [1, 0], [0, 1], [0, -1]];\n        for (var row = 0; row < Automata.GRID_N_ROWS; ++row) {\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; ++col) {\n                for (var i = 0; i < neighbs.length; ++i) {\n                    var neighbRow = row + neighbs[i][0];\n                    var neighbCol = col + neighbs[i][1];\n                    if (neighbRow < 0\n                        || neighbCol < 0\n                        || neighbRow >= Automata.GRID_N_ROWS\n                        || neighbCol >= Automata.GRID_N_COLUMNS) {\n                        continue;\n                    }\n                    var flowRate = 0.02;\n                    // air to air is very fast\n                    if (this.isAirCell(row, col) && this.isAirCell(neighbRow, neighbCol)) {\n                        flowRate = 0.2;\n                    }\n                    var neighbFluids = this.fluidsArray[neighbRow][neighbCol];\n                    var fluids = this.fluidsArray[row][col];\n                    for (var j = 0; j < fluids_1.Fluids.N_FLUIDS; ++j) {\n                        if (fluids[j] > neighbFluids[j]) {\n                            var diff = flowRate * (fluids[j] - neighbFluids[j]);\n                            fluidsDiff[row][col][j] -= diff;\n                            fluidsDiff[neighbRow][neighbCol][j] += diff;\n                        }\n                    }\n                }\n            }\n        }\n        this.validateFluidsArray();\n        // Apply fluidsDiff to fluids\n        for (var row = 0; row < Automata.GRID_N_ROWS; row++) {\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; col++) {\n                var fluids = this.fluidsArray[row][col];\n                var fluidDiff = fluidsDiff[row][col];\n                for (var i = 0; i < fluids_1.Fluids.N_FLUIDS; ++i) {\n                    fluids[i] += fluidDiff[i];\n                }\n            }\n        }\n    };\n    Automata.prototype.isPositionOnGrid = function (row, col) {\n        return row >= 0 && col >= 0 &&\n            row < Automata.GRID_N_ROWS && col < Automata.GRID_N_COLUMNS;\n    };\n    Automata.prototype.isAirCell = function (row, col) {\n        if (!this.isPositionOnGrid(row, col))\n            return false;\n        return row < 50 && !(this.fluidsArray[row][col] instanceof cell_1.Cell);\n    };\n    Automata.prototype.countAirNeighbors = function (row, col) {\n        var n = (this.isAirCell(row - 1, col) ? 1 : 0) +\n            (this.isAirCell(row + 1, col) ? 1 : 0) +\n            (this.isAirCell(row, col - 1) ? 1 : 0) +\n            (this.isAirCell(row, col + 1) ? 1 : 0);\n        return n;\n    };\n    Automata.prototype.draw = function () {\n        if (this.validateFluidsArray()) {\n            console.log('error in fluids, skipping draw');\n            return;\n        }\n        var scale = Automata.CELL_SCALE_PIXELS;\n        this.canvasCtx.lineWidth = 3;\n        this.canvasCtx.fillStyle = \"#7EC0DD\";\n        this.canvasCtx.fillRect(0, 0, Automata.GRID_N_COLUMNS * scale, scale * Automata.GRID_N_ROWS);\n        this.canvasCtx.fillRect(0, 0, 100, 100);\n        for (var row = 0; row < Automata.GRID_N_ROWS; row++) {\n            for (var col = 0; col < Automata.GRID_N_COLUMNS; col++) {\n                var fluids = this.fluidsArray[row][col].vector;\n                var waterContent = Math.max(Math.min(Math.round(fluids[fluids_1.Fluids.WATER]), 255), 0);\n                if (this.viewStyle === 'water') {\n                    var colorString = \"#\" + \"0064\" + this.getColorHex(waterContent);\n                    this.canvasCtx.fillStyle = colorString;\n                }\n                else if (this.viewStyle === 'glucose') {\n                    if (this.cellArray[row][col]) {\n                        this.canvasCtx.fillStyle = \"#\" + this.getColorHex(Math.min(255, Math.ceil(fluids[fluids_1.Fluids.GLUCOSE]))) + \"0000\";\n                    }\n                    else {\n                        this.canvasCtx.fillStyle = \"#000000\";\n                    }\n                }\n                else if (this.viewStyle === 'auxin') {\n                    var cell_2 = this.cellArray[row][col];\n                    if (cell_2) {\n                        this.canvasCtx.fillStyle = \"#\" + \"0000\" + this.getColorHex(Math.min(255, Math.ceil(255 * fluids[fluids_1.Fluids.SIGNALS_START].vector[0])));\n                    }\n                    else {\n                        this.canvasCtx.fillStyle = \"#000000\";\n                    }\n                }\n                else {\n                    var cell_3 = this.cellArray[row][col];\n                    if (cell_3) {\n                        this.canvasCtx.fillStyle = this.cellArray[row][col].type.color;\n                    }\n                    else if (row >= 50) {\n                        var cval = Math.ceil(waterContent / 4);\n                        // console.log(waterContent);\n                        this.canvasCtx.fillStyle = \"#3311\" + this.getColorHex(cval);\n                    }\n                    else {\n                        this.canvasCtx.fillStyle = \"#7EC0DD\";\n                    }\n                }\n                this.canvasCtx.fillRect(Math.floor(scale * col), Math.floor(scale * row), scale, scale);\n                // draw green outline around the plant\n                if (this.viewStyle == 'water' || this.viewStyle == 'glucose' || this.viewStyle == 'auxin') {\n                    this.canvasCtx.strokeStyle = \"#009900\";\n                    var neighbs = [[-1, 0], [1, 0], [0, 1], [0, -1]];\n                    var cell = this.cellArray[row][col];\n                    if (cell) {\n                        for (var i = 0; i < neighbs.length; ++i) {\n                            var nrow = row + neighbs[i][0];\n                            var ncol = col + neighbs[i][1];\n                            if (this.isPositionOnGrid(nrow, ncol) && !this.cellArray[nrow][ncol]) {\n                                this.canvasCtx.beginPath();\n                                if (neighbs[i][0] == -1) {\n                                    this.canvasCtx.moveTo(scale * col + 0.5, scale * row + 0.5);\n                                    this.canvasCtx.lineTo(scale * (col + 1) + 0.5, scale * row + 0.5);\n                                }\n                                else if (neighbs[i][0] == 1) {\n                                    this.canvasCtx.moveTo(scale * (col + 1) + 0.5, scale * (row + 1) + 0.5);\n                                    this.canvasCtx.lineTo(scale * col + 0.5, scale * (row + 1) + 0.5);\n                                }\n                                else if (neighbs[i][1] == -1) {\n                                    this.canvasCtx.moveTo(scale * col + 0.5, scale * (row + 1) + 0.5);\n                                    this.canvasCtx.lineTo(scale * col + 0.5, scale * row + 0.5);\n                                }\n                                else if (neighbs[i][1] == 1) {\n                                    this.canvasCtx.moveTo(scale * (col + 1) + 0.5, scale * row + 0.5);\n                                    this.canvasCtx.lineTo(scale * (col + 1) + 0.5, scale * (row + 1) + 0.5);\n                                }\n                                this.canvasCtx.stroke();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    Automata.prototype.getColorHex = function (byte) {\n        var colorString = \"\";\n        if (byte < 16) {\n            colorString += \"0\" + byte.toString(16);\n        }\n        else {\n            colorString += byte.toString(16);\n        }\n        return colorString;\n    };\n    Automata.GRID_N_COLUMNS = 120;\n    Automata.GRID_N_ROWS = 100;\n    Automata.CELL_SCALE_PIXELS = 8;\n    return Automata;\n}());\nexports.Automata = Automata;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/automata.ts\n ** module id = 2\n ** module chunks = 0\n **/","\"use strict\";\nvar cell_1 = require(\"./cell\");\nvar fluids_1 = require(\"./fluids\");\nvar automata_1 = require(\"./automata\");\nvar DNA = (function () {\n    function DNA() {\n        this.N_TYPES = 2;\n        /*\n      In nature, the gene controls the transcription product, and .\n      \n      Inputs of a cell:\n      - Signals\n      - Fluids\n      \n      Actions of a cell:\n      - Produce signals\n      - Duplicate\n      - Specialize\n      -\n      \n      Plant decisions are modeled as a markov chain.\n      Each cell type is a node on the markov chain.\n      Each cell type is also a 2 layer neural net.\n      Each cell type has a list of potential actions, which may be paramaterized by neighbor states.\n      The neural net's input is the fluid vector.\n      \n      Depending on the output of the neura\n      Each object in cellTypes is a\n      cellTypes is a markov chain. Each Markov state is a 2 layer neural net\n        */\n        this.cellTypes = [\n            {\n                cost: new fluids_1.Fluids(0, 20),\n                /*\n                (N_SIGNALS) x (N_SIGNALS+N_FLUIDS)\n                */\n                signalMatrix: [\n                    [1, 0, 0, 0, 0.2, 0.2],\n                    [0, 1, 1, 1, 0, 0],\n                    [0, 0, 1, 0, 0, 0],\n                    [0, 0, 0, 1, 0, 0],\n                ],\n                signalB: [-0.3, -0.5, 0.05, -0.05],\n                signalInit: [0, 0, 0, 1],\n                color: \"#ededbe\",\n                actions: [\n                    {\n                        name: 'demote',\n                        activator: {\n                            w: [0, 10, 0, 0],\n                            b: 0\n                        }\n                    },\n                    {\n                        name: 'grow',\n                        parameters: {\n                            direction: 'up',\n                            type: 0\n                        },\n                        activator: {\n                            w: [20, 0, 0, 0],\n                            b: 60\n                        }\n                    },\n                    {\n                        name: 'grow',\n                        parameters: {\n                            direction: 'right',\n                            type: 0\n                        },\n                        activator: {\n                            w: [20, 0, 0, 0],\n                            b: 2\n                        }\n                    },\n                    {\n                        name: 'grow',\n                        parameters: {\n                            direction: 'right',\n                            type: 1\n                        },\n                        activator: {\n                            w: [20, 0, 0, 0],\n                            b: 2\n                        }\n                    },\n                    {\n                        name: 'grow',\n                        parameters: {\n                            direction: 'left',\n                            type: 1\n                        },\n                        activator: {\n                            w: [20, 0, 0, 0],\n                            b: 2\n                        }\n                    },\n                    {\n                        name: 'nothing',\n                        activator: {\n                            w: [-2, 0, 0, 0],\n                            b: 2\n                        }\n                    }\n                ]\n            },\n            {\n                cost: new fluids_1.Fluids(0, 20),\n                signalMatrix: [\n                    [0.8, 0, 0, 0, 0, 0],\n                    [0, 1, 0, 0, 0, 0],\n                    [0, 0, 1, 0, 0, 0],\n                    [0, 0, 0, 1, 0, 0],\n                ],\n                signalB: [0.05, -0.5, 0.05, 0.05],\n                signalInit: [0, 0, 0, 0],\n                color: \"#8F8F6E\",\n                isLeaf: true,\n                actions: [\n                    {\n                        name: 'grow',\n                        parameters: {\n                            direction: 'right',\n                            type: 1\n                        },\n                        activator: {\n                            w: [20, 0, 0, 0],\n                            b: 2\n                        }\n                    },\n                    {\n                        name: 'grow',\n                        parameters: {\n                            direction: 'left',\n                            type: 1\n                        },\n                        activator: {\n                            w: [20, 0, 0, 0],\n                            b: 2\n                        }\n                    },\n                    {\n                        name: 'grow',\n                        parameters: {\n                            direction: 'right',\n                            type: 4\n                        },\n                        activator: {\n                            w: [20, 0, 0, 0],\n                            b: 4\n                        }\n                    },\n                    {\n                        name: 'grow',\n                        parameters: {\n                            direction: 'left',\n                            type: 4\n                        },\n                        activator: {\n                            w: [20, 0, 0, 0],\n                            b: 2\n                        }\n                    },\n                    {\n                        name: 'nothing',\n                        activator: {\n                            w: [-2, 0, 0, 0],\n                            b: 2\n                        }\n                    }\n                ]\n            },\n            {\n                cost: new fluids_1.Fluids(0, 20),\n                signalMatrix: [\n                    [0.8, 0, 0, 0, 0, 0],\n                    [0, 1, 0, 0, 0, 0],\n                    [0, 0, 1, 0, 0, 0],\n                    [0, 0, 0, 1, 0, 0],\n                ],\n                signalB: [0.05, -0.5, 0.05, 0.05],\n                signalInit: [0, 0, 0, 0],\n                color: \"#6E6E8F\",\n                actions: [\n                    {\n                        name: 'grow',\n                        parameters: {\n                            direction: 'down',\n                            type: 2\n                        },\n                        activator: {\n                            w: [20, 0, 0, 0],\n                            b: 2\n                        }\n                    },\n                    {\n                        name: 'grow',\n                        parameters: {\n                            direction: 'right',\n                            type: 2\n                        },\n                        activator: {\n                            w: [20, 0, 0, 0],\n                            b: 2\n                        }\n                    },\n                    {\n                        name: 'grow',\n                        parameters: {\n                            direction: 'right',\n                            type: 3\n                        },\n                        activator: {\n                            w: [20, 0, 0, 0],\n                            b: 2\n                        }\n                    },\n                    {\n                        name: 'grow',\n                        parameters: {\n                            direction: 'left',\n                            type: 3\n                        },\n                        activator: {\n                            w: [20, 0, 0, 0],\n                            b: 2\n                        }\n                    },\n                    {\n                        name: 'nothing',\n                        activator: {\n                            w: [-2, 0, 0, 0],\n                            b: 2\n                        }\n                    }\n                ]\n            },\n            {\n                cost: new fluids_1.Fluids(0, 20),\n                signalMatrix: [\n                    [0.8, 0, 0, 0, 0, 0],\n                    [0, 1, 0, 0, 0, 0],\n                    [0, 0, 1, 0, 0, 0],\n                    [0, 0, 0, 1, 0, 0],\n                ],\n                signalB: [0.05, -0.5, 0.05, 0.05],\n                signalInit: [0, 0, 0, 0],\n                color: \"#8F6E7F\",\n                actions: [\n                    {\n                        name: 'grow',\n                        parameters: {\n                            direction: 'right',\n                            type: 3\n                        },\n                        activator: {\n                            w: [20, 0, 0, 0],\n                            b: 2\n                        }\n                    },\n                    {\n                        name: 'grow',\n                        parameters: {\n                            direction: 'left',\n                            type: 3\n                        },\n                        activator: {\n                            w: [20, 0, 0, 0],\n                            b: 2\n                        }\n                    },\n                    {\n                        name: 'nothing',\n                        activator: {\n                            w: [-2, 0, 0, 0],\n                            b: 2\n                        }\n                    }\n                ]\n            },\n            {\n                cost: new fluids_1.Fluids(0, 30),\n                signalMatrix: [\n                    [0.8, 0, 0, 0, 0, 0],\n                    [0, 1, 0, 0, 0, 0],\n                    [0, 0, 1, 0, 0, 0],\n                    [0, 0, 0, 1, 0, 0],\n                ],\n                signalB: [0.05, -0.5, 0.05, 0.05],\n                signalInit: [0, 0, 0, 0],\n                color: \"#80C4A1\",\n                actions: [\n                    {\n                        name: 'grow',\n                        parameters: {\n                            direction: 'right',\n                            type: 4\n                        },\n                        activator: {\n                            w: [20, 0, 0, 0],\n                            b: 2\n                        }\n                    },\n                    {\n                        name: 'grow',\n                        parameters: {\n                            direction: 'left',\n                            type: 4\n                        },\n                        activator: {\n                            w: [20, 0, 0, 0],\n                            b: 2\n                        }\n                    },\n                    {\n                        name: 'nothing',\n                        activator: {\n                            w: [-2, 0, 0, 0],\n                            b: 2\n                        }\n                    }\n                ]\n            }\n        ];\n        window['dna'] = this;\n    }\n    DNA.prototype.plantSeed = function (grid) {\n        var c1 = new cell_1.Cell(this, 0, new fluids_1.Fluids(1000, 1000), automata_1.Automata.GRID_N_ROWS / 2, automata_1.Automata.GRID_N_COLUMNS / 2), c2 = new cell_1.Cell(this, 1, new fluids_1.Fluids(1000, 1000), automata_1.Automata.GRID_N_ROWS / 2 + 1, automata_1.Automata.GRID_N_COLUMNS / 2);\n        var seed = [c1, c2];\n        grid[c1.row][c1.col] = c1;\n        grid[c2.row][c2.col] = c2;\n        return seed;\n    };\n    DNA.prototype.serialize = function () {\n        return {\n            cellTypes: this.cellTypes\n        };\n    };\n    DNA.prototype.l2norm = function (arr) {\n        var n = 0;\n        for (var i = 0; i < arr.length; ++i) {\n            n += arr[i] * arr[i];\n        }\n        return Math.sqrt(n);\n    };\n    DNA.prototype.l1norm = function (arr) {\n        var n = 0;\n        for (var i = 0; i < arr.length; ++i) {\n            n += arr[i];\n        }\n        return n;\n    };\n    DNA.prototype.distanceToActivator = function (fluids, activator) {\n        var normW = this.l2norm(activator.w);\n        var d = 0;\n        for (var i = 0; i < length; ++i) {\n            d += fluids[i] * activator[i];\n        }\n        d += activator.b;\n        return d / normW;\n    };\n    /*\n    Sigmoid activator.\n    Returns value from 0 to 1 given f from -inf to inf.\n    */\n    DNA.prototype.activatorFunction = function (v) {\n        return 1 / (1 + Math.exp(-v));\n    };\n    DNA.prototype.weightedChoose = function (values, weights) {\n        var norm = this.l1norm(weights);\n        var rand = Math.random();\n        var prob = 0;\n        for (var i = 0; i < values.length; ++i) {\n            var w = weights[i] / norm;\n            prob += w;\n            if (rand <= prob) {\n                return values[i];\n            }\n        }\n    };\n    DNA.prototype.chooseAction = function (signals, cellType) {\n        var actions = cellType.actions;\n        var activators = new Array(actions.length);\n        for (var i = 0; i < activators.length; ++i) {\n            activators[i] = this.activatorFunction(this.distanceToActivator(signals, actions[i].activator));\n        }\n        // console.log('activators', activators, 'actions', actions);\n        return this.weightedChoose(actions, activators);\n    };\n    return DNA;\n}());\nexports.DNA = DNA;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/dna.ts\n ** module id = 3\n ** module chunks = 0\n **/","\"use strict\";\nvar fluids_1 = require(\"./fluids\");\n/*\nCell is a fleighweight object for the Grid. Systems.\nPlus they also have context for fitting into the Grid.\n*/\nvar Cell = (function () {\n    function Cell(dna, type, fluids, row, col) {\n        this.row = row;\n        this.col = col;\n        this.fluids = fluids;\n        if (typeof type === 'number') {\n            this.type = dna.cellTypes[type];\n        }\n        else {\n            this.type = type;\n        }\n        this.dna = dna;\n        for (var i = 0; i < fluids_1.Fluids.N_SIGNALS; ++i) {\n            this.fluids[fluids_1.Fluids.SIGNALS_START + i] = this.type.signalInit[i];\n        }\n    }\n    Cell.prototype.updateSignals = function () {\n        // multiply by matrix\n        // var newSignals = new Array(Fluids.N_SIGNALS);\n        // for (var i = 0; i < newSignals.length; ++i) {\n        //     newSignals[i] = 0;\n        // }\n        // var mtx = this.type.signalMatrix;\n        // for (var i = 0; i < newSignals.length; i++) {\n        //     for (var j = 0; j < Fluids.N_SIGNALS; j++) { // first SIGNALS columns of matrix...\n        //         newSignals[i] += this.fluids.vector[j+Fluids.SIGNALS_START] * mtx[i][j];\n        //     }\n        //     for (j = 0; j < this.fluids.vector.length; ++j) {\n        //         newSignals[i] += this.fluids.vector[j] * mtx[i][j+this.signals.vector.length];\n        //     }\n        // }\n        // var vec = this.dna.cellTypes[this.type].signalB;\n        // // console.log('signals', newSignals, 'mtx', mtx, 'vec', vec);\n        // for (var i = 0; i < vec.length; i++) {\n        //     newSignals[i] += vec[i];\n        // }\n        // for (var i = 0; i < newSignals.length; i++) {\n        //     this.signals.vector[i] = Math.max(0, Math.min(1, newSignals[i]));\n        // }\n    };\n    Cell.prototype.update = function () {\n    };\n    /*\n    returns -\n        {\n            type: 'grow'\n            parameters: {\n                'up', 'right', 'down', 'left'\n            }\n        }\n\n    */\n    Cell.prototype.getAction = function () {\n        return this.dna.chooseAction(this.signals, this.type);\n    };\n    return Cell;\n}());\nexports.Cell = Cell;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/cell.ts\n ** module id = 4\n ** module chunks = 0\n **/","\"use strict\";\nvar Fluids = (function () {\n    function Fluids(water, glucose) {\n        if (water === void 0) { water = 100; }\n        if (glucose === void 0) { glucose = 0; }\n        this.vector = new Array(Fluids.N_FLUIDS);\n        for (var i = 0; i < Fluids.N_FLUIDS; ++i) {\n            this.vector[i] = 0;\n        }\n        this.vector[Fluids.WATER] = water;\n        this.vector[Fluids.GLUCOSE] = glucose;\n    }\n    Fluids.WATER = 0;\n    Fluids.GLUCOSE = 1;\n    Fluids.AUXIN = 2;\n    Fluids.SIGNALS_START = 2;\n    Fluids.N_SIGNALS = 4;\n    Fluids.N_FLUIDS = 2 + Fluids.N_SIGNALS;\n    return Fluids;\n}());\nexports.Fluids = Fluids;\nvar Reactions = (function () {\n    function Reactions() {\n    }\n    return Reactions;\n}());\nexports.Reactions = Reactions;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/fluids.ts\n ** module id = 5\n ** module chunks = 0\n **/","\"use strict\";\n/*\nRadian-based angles.\n*/\nvar Angle = (function () {\n    function Angle() {\n    }\n    /*\n    Return a random Direction enum based on the angle.\n    sampleDirection(0) returns Direction.RIGHT.\n    sampleDirection(Math.PI/4) is a 50-50 chance UP or RIGHT.\n    */\n    Angle.sampleDirection = function (angle) {\n        angle = Angle.canonical(angle);\n        if (angle == Angle.RIGHT)\n            return Directions.RIGHT;\n        if (angle == Angle.UP)\n            return Directions.UP;\n        if (angle == Angle.LEFT)\n            return Directions.LEFT;\n        if (angle == Angle.DOWN)\n            return Directions.DOWN;\n        // d1, d2 specify the quadrant\n        var d1, d2;\n        if (angle > Angle.RIGHT && angle < Angle.UP) {\n            d1 = Directions.RIGHT;\n            d2 = Directions.UP;\n        }\n        else if (angle > Angle.UP && angle < Angle.LEFT) {\n            d1 = Directions.UP;\n            d2 = Directions.LEFT;\n        }\n        else if (angle > Angle.LEFT && angle < Angle.DOWN) {\n            d1 = Directions.LEFT;\n            d2 = Directions.DOWN;\n        }\n        else {\n            d1 = Directions.DOWN;\n            d2 = Directions.RIGHT;\n        }\n        // determine how much the angle is pointing toward d1\n        angle = angle % (Math.PI / 2);\n        var sin = Math.sin(angle), cos = Math.cos(angle);\n        if (Math.random() < cos / (sin + cos)) {\n            return d1;\n        }\n        else {\n            return d2;\n        }\n    };\n    /* Returns angle between 0 and 2 PI */\n    Angle.canonical = function (angle) {\n        angle = angle % (2 * Math.PI);\n        if (angle < 0) {\n            return angle + 2 * Math.PI;\n        }\n        return angle;\n    };\n    /*\n    Computes angle of the given (x,y) vector\n    */\n    Angle.vectorAngle = function (x, y) {\n        return Math.atan2(y, x);\n    };\n    Angle.RIGHT = 0;\n    Angle.UP = Math.PI / 2;\n    Angle.LEFT = Math.PI;\n    Angle.DOWN = 3 * Math.PI / 2;\n    return Angle;\n}());\nexports.Angle = Angle;\n/*\nCardinal direction enums\n*/\nvar Directions = (function () {\n    function Directions() {\n    }\n    Directions.RIGHT = 0;\n    Directions.UP = 1;\n    Directions.LEFT = 2;\n    Directions.DOWN = 3;\n    return Directions;\n}());\nexports.Directions = Directions;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/angle.ts\n ** module id = 6\n ** module chunks = 0\n **/"],"sourceRoot":""}